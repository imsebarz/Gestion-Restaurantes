This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
backend/
  application/
    interfaces/
      IMenuItemRepository.ts
      IOrderRepository.ts
      ITableRepository.ts
      IUserRepository.ts
    useCases/
      CreateOrderByQrCode.ts
      ListMenuItems.ts
      TableManagement.ts
      UpdateOrderStatus.ts
      UserAuthentication.ts
  domain/
    entities/
      MenuItem.ts
      Order.ts
      Table.ts
      User.ts
    valueObjects/
      Pagination.ts
    index.ts
  infrastructure/
    prisma/
      migrations/
        20250424205455_init/
          migration.sql
        20250424232338_init/
          migration.sql
        20250603202909_init/
          migration.sql
        20250604012647_init/
          migration.sql
        20250605134542_add_qr_code_to_tables/
          migration.sql
        20250610013940_add_image_url_to_menu_items/
          migration.sql
        migration_lock.toml
      client.ts
      schema.prisma
      seed.ts
    repositories/
      PrismaMenuItemRepository.ts
      PrismaOrderRepository.ts
      PrismaTableRepository.ts
      PrismaUserRepository.ts
  interfaces/
    graphql/
      resolvers/
        menuResolvers.ts
        orderResolvers.ts
        paymentResolvers.ts
        subscriptionResolvers.ts
        tableResolvers.ts
        userResolvers.ts
      utils/
        auth.ts
      context.ts
      pubsub.ts
  src/
    server.ts
  .gitignore
  package.json
  README.md
  repomix-output.xml
  tsconfig.json
frontend-nextjs/
  public/
    file.svg
    globe.svg
    next.svg
    vercel.svg
    window.svg
  src/
    app/
      menu/
        [qrCode]/
          page.tsx
      client-provider.tsx
      globals.css
      layout.tsx
      page.tsx
    components/
      dashboard/
        Filters.tsx
        MenuTab.tsx
        OrdersTab.tsx
        Pagination.tsx
        TablesTab.tsx
      ui/
        Badge.tsx
        Button.tsx
        Card.tsx
        index.ts
        Input.tsx
      Auth.tsx
      Dashboard.tsx
    hooks/
      useDashboardActions.ts
      useDashboardData.ts
      useDashboardUtils.ts
    lib/
      queries.ts
      styles.ts
    types.ts
  .gitignore
  eslint.config.mjs
  next.config.ts
  package.json
  postcss.config.mjs
  README.md
  tsconfig.json
scripts/
  build.sh
  deploy.sh
  dev.sh
  logs.sh
  status.sh
  test.sh
CI-CD-README.md
Makefile
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="backend/application/interfaces/IUserRepository.ts">
import { User, RoleEnum } from "../../domain/entities/User";

export interface IUserRepository {
  findById(id: number): Promise<User | null>;
  findByEmail(email: string): Promise<User | null>;
  create(userData: {
    email: string;
    password: string;
    role: RoleEnum;
  }): Promise<User>;
  update(id: number, userData: Partial<User>): Promise<User>;
  delete(id: number): Promise<void>;
}
</file>

<file path="backend/application/useCases/ListMenuItems.ts">
import { MenuItem } from "../../domain/entities/MenuItem";
import { Connection, Cursor } from "../../domain/valueObjects/Pagination";
import {
  IMenuItemRepository,
  MenuItemFilter,
  MenuItemSort,
} from "../interfaces/IMenuItemRepository";

export interface ListMenuItemsRequest {
  filter?: MenuItemFilter;
  sort?: MenuItemSort;
  first?: number;
  after?: Cursor;
}

export class ListMenuItems {
  constructor(private readonly menuItemRepository: IMenuItemRepository) {}

  async execute(request: ListMenuItemsRequest): Promise<Connection<MenuItem>> {
    return this.menuItemRepository.findMany(
      request.filter,
      request.sort,
      request.first,
      request.after,
    );
  }
}
</file>

<file path="backend/application/useCases/TableManagement.ts">
import { Table } from "../../domain/entities/Table";
import { Connection, Cursor } from "../../domain/valueObjects/Pagination";
import {
  ITableRepository,
  TableFilter,
  TableSort,
} from "../interfaces/ITableRepository";

export interface ListTablesRequest {
  filter?: TableFilter;
  sort?: TableSort;
  first?: number;
  after?: Cursor;
}

export interface CreateTableRequest {
  number?: number;
  capacity: number;
  generateQrCode?: boolean;
}

export class ListTables {
  constructor(private readonly tableRepository: ITableRepository) {}

  async execute(request: ListTablesRequest): Promise<Connection<Table>> {
    return this.tableRepository.findMany(
      request.filter,
      request.sort,
      request.first,
      request.after,
    );
  }
}

export class CreateTable {
  constructor(private readonly tableRepository: ITableRepository) {}

  async execute(request: CreateTableRequest): Promise<Table> {
    const number =
      request.number ?? (await this.tableRepository.getNextTableNumber());

    // Check if table number already exists
    const existingTable = await this.tableRepository.findByNumber(number);
    if (existingTable) {
      throw new Error(`Mesa con número ${number} ya existe`);
    }

    let qrCode: string | undefined;
    if (request.generateQrCode) {
      const table = new Table(0, number, request.capacity);
      qrCode = table.generateQrCode();
    }

    return this.tableRepository.create({
      number,
      capacity: request.capacity,
      qrCode,
    });
  }
}

export class TableManagement {
  constructor(private readonly tableRepository: ITableRepository) {}

  async listTables(
    filter?: {
      number?: number;
      capacityMin?: number;
      capacityMax?: number;
      hasQrCode?: boolean;
    },
    sort?: {
      field: "id" | "number" | "capacity" | "orderCount";
      order: "asc" | "desc";
    },
    limit?: number,
    offset?: number
  ): Promise<Table[]> {
    return this.tableRepository.findMany(filter, sort, limit, offset);
  }

  async addTable(): Promise<Table> {
    // Find the highest table number and add 1
    const tables = await this.tableRepository.findMany(
      {},
      { field: "number", order: "desc" },
      1,
      0
    );
    const nextNumber = tables.length > 0 ? tables[0].number + 1 : 1;

    return this.tableRepository.create({
      number: nextNumber,
      capacity: 4, // default capacity
    });
  }

  async removeTable(): Promise<Table> {
    // Remove the table with the highest number
    const tables = await this.tableRepository.findMany(
      {},
      { field: "number", order: "desc" },
      1,
      0
    );

    if (tables.length === 0) {
      throw new Error("No tables to remove");
    }

    return this.tableRepository.delete(tables[0].id);
  }

  async generateQrCode(tableId: number): Promise<Table> {
    // Generate a unique QR code using table ID and timestamp
    const qrCode = `table-${tableId}-${Date.now()}`;

    return this.tableRepository.update(tableId, { qrCode });
  }
}
</file>

<file path="backend/application/useCases/UserAuthentication.ts">
import { User, RoleEnum } from "../../domain/entities/User";
import { IUserRepository } from "../interfaces/IUserRepository";

export interface AuthenticateUserRequest {
  email: string;
  password: string;
}

export interface CreateUserRequest {
  email: string;
  password: string;
  role?: RoleEnum;
}

export class AuthenticateUser {
  constructor(private readonly userRepository: IUserRepository) {}

  async execute(request: AuthenticateUserRequest): Promise<User> {
    const user = await this.userRepository.findByEmail(request.email);
    if (!user) {
      throw new Error("Usuario no existe");
    }

    const bcrypt = require("bcryptjs");
    const isValid = await bcrypt.compare(request.password, user.getPassword());
    if (!isValid) {
      throw new Error("Contraseña inválida");
    }

    return user;
  }
}

export class CreateUser {
  constructor(private readonly userRepository: IUserRepository) {}

  async execute(request: CreateUserRequest): Promise<User> {
    const existingUser = await this.userRepository.findByEmail(request.email);
    if (existingUser) {
      throw new Error("El usuario ya existe");
    }

    const bcrypt = require("bcryptjs");
    const hashedPassword = await bcrypt.hash(request.password, 10);

    return this.userRepository.create({
      email: request.email,
      password: hashedPassword,
      role: request.role || RoleEnum.STAFF,
    });
  }
}
</file>

<file path="backend/domain/entities/Order.ts">
export enum OrderStatus {
  OPEN = "OPEN",
  PENDING = "PENDING",
  PREPARING = "PREPARING",
  READY = "READY",
  DELIVERED = "DELIVERED",
  PAID = "PAID",
  CANCELLED = "CANCELLED",
}

export class OrderItem {
  constructor(
    public readonly id: number,
    public readonly orderId: number,
    public readonly menuItemId: number,
    public readonly quantity: number,
    public readonly price: number,
  ) {}

  public getTotal(): number {
    return this.quantity * this.price;
  }
}

export class Order {
  constructor(
    public readonly id: number,
    public readonly status: OrderStatus,
    public readonly tableId: number,
    public readonly userId: number,
    public readonly createdAt: Date = new Date(),
    public readonly orderItems: OrderItem[] = [],
  ) {}

  public isPaid(): boolean {
    return this.status === OrderStatus.PAID;
  }

  public isCancelled(): boolean {
    return this.status === OrderStatus.CANCELLED;
  }

  public canBeModified(): boolean {
    return ![
      OrderStatus.PAID,
      OrderStatus.CANCELLED,
      OrderStatus.DELIVERED,
    ].includes(this.status);
  }

  public getTotalAmount(): number {
    return this.orderItems.reduce((total, item) => total + item.getTotal(), 0);
  }

  public changeStatus(newStatus: OrderStatus): Order {
    if (!this.canBeModified() && newStatus !== OrderStatus.PAID) {
      throw new Error("Cannot modify a completed or cancelled order");
    }

    return new Order(
      this.id,
      newStatus,
      this.tableId,
      this.userId,
      this.createdAt,
      this.orderItems,
    );
  }

  public cancel(): Order {
    return this.changeStatus(OrderStatus.CANCELLED);
  }

  public markAsPaid(): Order {
    return this.changeStatus(OrderStatus.PAID);
  }
}
</file>

<file path="backend/domain/entities/Table.ts">
export class Table {
  constructor(
    public readonly id: number,
    public readonly number: number,
    public readonly capacity: number,
    public readonly qrCode?: string,
  ) {}

  public hasQrCode(): boolean {
    return !!this.qrCode;
  }

  public canAccommodate(guests: number): boolean {
    return this.capacity >= guests;
  }

  public generateQrCode(): string {
    return `table-${this.id}-${Date.now()}`;
  }

  public withQrCode(qrCode: string): Table {
    return new Table(this.id, this.number, this.capacity, qrCode);
  }
}
</file>

<file path="backend/domain/entities/User.ts">
export enum RoleEnum {
  SUPERADMIN = "SUPERADMIN",
  MANAGER = "MANAGER",
  STAFF = "STAFF",
}

export class User {
  constructor(
    public readonly id: number,
    public readonly email: string,
    private readonly password: string,
    public readonly role: RoleEnum,
    public readonly createdAt: Date = new Date(),
  ) {}

  public hasRole(allowedRoles: RoleEnum[]): boolean {
    return allowedRoles.includes(this.role);
  }

  public isManager(): boolean {
    return this.role === RoleEnum.MANAGER || this.role === RoleEnum.SUPERADMIN;
  }

  public canManageMenu(): boolean {
    return this.role === RoleEnum.MANAGER || this.role === RoleEnum.SUPERADMIN;
  }

  public canManageOrders(): boolean {
    return this.role !== undefined; // All authenticated users can manage orders
  }

  public getPassword(): string {
    return this.password;
  }
}
</file>

<file path="backend/domain/valueObjects/Pagination.ts">
export class Cursor {
  constructor(public readonly value: string) {}

  public static fromId(id: number): Cursor {
    return new Cursor(Buffer.from(id.toString()).toString("base64"));
  }

  public toId(): number {
    return parseInt(Buffer.from(this.value, "base64").toString("ascii"));
  }

  public static empty(): Cursor {
    return new Cursor("");
  }

  public isEmpty(): boolean {
    return this.value === "";
  }
}

export class PaginationInfo {
  constructor(
    public readonly hasNextPage: boolean,
    public readonly hasPreviousPage: boolean,
    public readonly startCursor?: Cursor,
    public readonly endCursor?: Cursor,
  ) {}
}

export class Edge<T> {
  constructor(
    public readonly node: T,
    public readonly cursor: Cursor,
  ) {}
}

export class Connection<T> {
  constructor(
    public readonly edges: Edge<T>[],
    public readonly pageInfo: PaginationInfo,
  ) {}
}
</file>

<file path="backend/domain/index.ts">
export * from "./entities/User";
export * from "./entities/MenuItem";
export * from "./entities/Table";
export * from "./entities/Order";
export * from "./valueObjects/Pagination";
</file>

<file path="backend/infrastructure/prisma/migrations/20250424205455_init/migration.sql">
-- CreateEnum
CREATE TYPE "Role" AS ENUM ('USER', 'ADMIN');

-- CreateEnum
CREATE TYPE "OrderStatus" AS ENUM ('PENDING', 'PREPARING', 'READY', 'DELIVERED', 'PAID', 'CANCELLED');

-- CreateEnum
CREATE TYPE "PaymentType" AS ENUM ('CASH', 'CARD', 'OTHER');

-- CreateTable
CREATE TABLE "User" (
    "id" SERIAL NOT NULL,
    "email" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "password" TEXT NOT NULL,
    "role" "Role" NOT NULL DEFAULT 'USER',

    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Item" (
    "id" SERIAL NOT NULL,
    "title" TEXT NOT NULL,
    "description" TEXT NOT NULL,
    "imageUrl" TEXT NOT NULL,
    "price" DOUBLE PRECISION NOT NULL,

    CONSTRAINT "Item_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Table" (
    "id" TEXT NOT NULL,
    "number" SERIAL NOT NULL,

    CONSTRAINT "Table_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Order" (
    "id" SERIAL NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "tableId" TEXT NOT NULL,
    "itemId" INTEGER NOT NULL,
    "paymentId" INTEGER,
    "status" "OrderStatus" NOT NULL DEFAULT 'PENDING',

    CONSTRAINT "Order_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Payment" (
    "id" SERIAL NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "type" "PaymentType" NOT NULL,

    CONSTRAINT "Payment_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "User_email_key" ON "User"("email");

-- CreateIndex
CREATE UNIQUE INDEX "Table_number_key" ON "Table"("number");

-- AddForeignKey
ALTER TABLE "Order" ADD CONSTRAINT "Order_tableId_fkey" FOREIGN KEY ("tableId") REFERENCES "Table"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Order" ADD CONSTRAINT "Order_itemId_fkey" FOREIGN KEY ("itemId") REFERENCES "Item"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Order" ADD CONSTRAINT "Order_paymentId_fkey" FOREIGN KEY ("paymentId") REFERENCES "Payment"("id") ON DELETE SET NULL ON UPDATE CASCADE;
</file>

<file path="backend/infrastructure/prisma/migrations/20250424232338_init/migration.sql">
/*
  Warnings:

  - The values [USER] on the enum `Role` will be removed. If these variants are still used in the database, this will fail.

*/
-- AlterEnum
BEGIN;
CREATE TYPE "Role_new" AS ENUM ('SUPERADMIN', 'ADMIN', 'CAJERO', 'MESERO', 'CLIENTE');
ALTER TABLE "User" ALTER COLUMN "role" DROP DEFAULT;
ALTER TABLE "User" ALTER COLUMN "role" TYPE "Role_new" USING ("role"::text::"Role_new");
ALTER TYPE "Role" RENAME TO "Role_old";
ALTER TYPE "Role_new" RENAME TO "Role";
DROP TYPE "Role_old";
ALTER TABLE "User" ALTER COLUMN "role" SET DEFAULT 'CLIENTE';
COMMIT;

-- AlterTable
ALTER TABLE "User" ALTER COLUMN "role" SET DEFAULT 'CLIENTE';
</file>

<file path="backend/infrastructure/prisma/migrations/20250603202909_init/migration.sql">
/*
  Warnings:

  - You are about to alter the column `price` on the `Item` table. The data in that column could be lost. The data in that column will be cast from `DoublePrecision` to `Decimal(65,30)`.

*/
-- AlterTable
ALTER TABLE "Item" ADD COLUMN     "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
ALTER COLUMN "price" SET DATA TYPE DECIMAL(65,30);

-- AlterTable
ALTER TABLE "Table" ADD COLUMN     "capacity" INTEGER DEFAULT 4,
ADD COLUMN     "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP;

-- AlterTable
ALTER TABLE "User" ADD COLUMN     "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP;

-- CreateIndex
CREATE INDEX "Order_tableId_idx" ON "Order"("tableId");

-- CreateIndex
CREATE INDEX "Order_itemId_idx" ON "Order"("itemId");

-- CreateIndex
CREATE INDEX "Order_paymentId_idx" ON "Order"("paymentId");
</file>

<file path="backend/infrastructure/prisma/migrations/20250604012647_init/migration.sql">
/*
  Warnings:

  - You are about to drop the `Item` table. If the table is not empty, all the data it contains will be lost.
  - You are about to drop the `Order` table. If the table is not empty, all the data it contains will be lost.
  - You are about to drop the `Payment` table. If the table is not empty, all the data it contains will be lost.
  - You are about to drop the `Table` table. If the table is not empty, all the data it contains will be lost.
  - You are about to drop the `User` table. If the table is not empty, all the data it contains will be lost.

*/
-- CreateEnum
CREATE TYPE "RoleEnum" AS ENUM ('SUPERADMIN', 'MANAGER', 'STAFF');

-- DropForeignKey
ALTER TABLE "Order" DROP CONSTRAINT "Order_itemId_fkey";

-- DropForeignKey
ALTER TABLE "Order" DROP CONSTRAINT "Order_paymentId_fkey";

-- DropForeignKey
ALTER TABLE "Order" DROP CONSTRAINT "Order_tableId_fkey";

-- DropTable
DROP TABLE "Item";

-- DropTable
DROP TABLE "Order";

-- DropTable
DROP TABLE "Payment";

-- DropTable
DROP TABLE "Table";

-- DropTable
DROP TABLE "User";

-- DropEnum
DROP TYPE "OrderStatus";

-- DropEnum
DROP TYPE "PaymentType";

-- DropEnum
DROP TYPE "Role";

-- CreateTable
CREATE TABLE "users" (
    "id" SERIAL NOT NULL,
    "email" TEXT NOT NULL,
    "password" TEXT NOT NULL,
    "role" "RoleEnum" NOT NULL DEFAULT 'STAFF',
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "users_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "tables" (
    "id" SERIAL NOT NULL,
    "number" INTEGER NOT NULL,
    "capacity" INTEGER NOT NULL DEFAULT 4,

    CONSTRAINT "tables_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "menu_items" (
    "id" SERIAL NOT NULL,
    "sku" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "price" MONEY NOT NULL,
    "isAvailable" BOOLEAN NOT NULL DEFAULT true,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "menu_items_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "orders" (
    "id" SERIAL NOT NULL,
    "status" TEXT NOT NULL DEFAULT 'OPEN',
    "tableId" INTEGER NOT NULL,
    "userId" INTEGER NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "orders_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "order_items" (
    "id" SERIAL NOT NULL,
    "orderId" INTEGER NOT NULL,
    "menuItemId" INTEGER NOT NULL,
    "quantity" INTEGER NOT NULL DEFAULT 1,
    "price" MONEY NOT NULL,

    CONSTRAINT "order_items_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "payments" (
    "id" SERIAL NOT NULL,
    "orderId" INTEGER NOT NULL,
    "amount" MONEY NOT NULL,
    "method" TEXT NOT NULL,
    "paidAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "payments_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "users_email_key" ON "users"("email");

-- CreateIndex
CREATE UNIQUE INDEX "tables_number_key" ON "tables"("number");

-- CreateIndex
CREATE UNIQUE INDEX "menu_items_sku_key" ON "menu_items"("sku");

-- CreateIndex
CREATE INDEX "orders_status_idx" ON "orders"("status");

-- CreateIndex
CREATE UNIQUE INDEX "payments_orderId_key" ON "payments"("orderId");

-- AddForeignKey
ALTER TABLE "orders" ADD CONSTRAINT "orders_tableId_fkey" FOREIGN KEY ("tableId") REFERENCES "tables"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "orders" ADD CONSTRAINT "orders_userId_fkey" FOREIGN KEY ("userId") REFERENCES "users"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "order_items" ADD CONSTRAINT "order_items_orderId_fkey" FOREIGN KEY ("orderId") REFERENCES "orders"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "order_items" ADD CONSTRAINT "order_items_menuItemId_fkey" FOREIGN KEY ("menuItemId") REFERENCES "menu_items"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "payments" ADD CONSTRAINT "payments_orderId_fkey" FOREIGN KEY ("orderId") REFERENCES "orders"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
</file>

<file path="backend/infrastructure/prisma/migrations/20250605134542_add_qr_code_to_tables/migration.sql">
/*
  Warnings:

  - A unique constraint covering the columns `[qrCode]` on the table `tables` will be added. If there are existing duplicate values, this will fail.

*/
-- AlterTable
ALTER TABLE "tables" ADD COLUMN     "qrCode" TEXT;

-- CreateIndex
CREATE UNIQUE INDEX "tables_qrCode_key" ON "tables"("qrCode");
</file>

<file path="backend/infrastructure/prisma/migrations/20250610013940_add_image_url_to_menu_items/migration.sql">
-- AlterTable
ALTER TABLE "menu_items" ADD COLUMN     "imageUrl" TEXT DEFAULT 'https://images.unsplash.com/photo-1546833999-b9f581a1996d?w=400&h=300&fit=crop';
</file>

<file path="backend/infrastructure/prisma/migrations/migration_lock.toml">
# Please do not edit this file manually
# It should be added in your version-control system (i.e. Git)
provider = "postgresql"
</file>

<file path="backend/infrastructure/prisma/client.ts">
import { PrismaClient } from "@prisma/client";

const prisma = new PrismaClient();

export default prisma;
</file>

<file path="backend/infrastructure/repositories/PrismaUserRepository.ts">
import { IUserRepository } from "../../application/interfaces/IUserRepository";
import { User, RoleEnum } from "../../domain/entities/User";
import prisma from "../prisma/client";

export class PrismaUserRepository implements IUserRepository {
  async findById(id: number): Promise<User | null> {
    const user = await prisma.user.findUnique({
      where: { id },
    });

    if (!user) return null;

    return new User(
      user.id,
      user.email,
      user.password,
      user.role as RoleEnum,
      user.createdAt,
    );
  }

  async findByEmail(email: string): Promise<User | null> {
    const user = await prisma.user.findUnique({
      where: { email },
    });

    if (!user) return null;

    return new User(
      user.id,
      user.email,
      user.password,
      user.role as RoleEnum,
      user.createdAt,
    );
  }

  async create(userData: {
    email: string;
    password: string;
    role: RoleEnum;
  }): Promise<User> {
    const user = await prisma.user.create({
      data: {
        email: userData.email,
        password: userData.password,
        role: userData.role,
      },
    });

    return new User(
      user.id,
      user.email,
      user.password,
      user.role as RoleEnum,
      user.createdAt,
    );
  }

  async update(id: number, userData: Partial<User>): Promise<User> {
    const updateData: any = {};
    if (userData.email) updateData.email = userData.email;
    if (userData.role) updateData.role = userData.role;

    const user = await prisma.user.update({
      where: { id },
      data: updateData,
    });

    return new User(
      user.id,
      user.email,
      user.password,
      user.role as RoleEnum,
      user.createdAt,
    );
  }

  async delete(id: number): Promise<void> {
    await prisma.user.delete({
      where: { id },
    });
  }
}
</file>

<file path="backend/interfaces/graphql/resolvers/subscriptionResolvers.ts">
import { pubsub, SUBSCRIPTION_EVENTS } from "../pubsub";

export const subscriptionResolvers = {
  Subscription: {
    orderCreated: {
      subscribe: () => pubsub.asyncIterableIterator([SUBSCRIPTION_EVENTS.ORDER_CREATED]),
    },
    orderUpdated: {
      subscribe: () => pubsub.asyncIterableIterator([SUBSCRIPTION_EVENTS.ORDER_UPDATED]),
    },
    orderStatusChanged: {
      subscribe: () => pubsub.asyncIterableIterator([SUBSCRIPTION_EVENTS.ORDER_STATUS_CHANGED]),
    },
  },
};
</file>

<file path="backend/interfaces/graphql/utils/auth.ts">
import { GraphQLContext } from "../context";
import { RoleEnum } from "@prisma/client";

/**
 * Validates that the user has the required role to perform an action
 * @param context GraphQL context containing user information
 * @param allowedRoles Array of roles that are allowed to perform the action
 * @throws Error if user is not authenticated or doesn't have required role
 */
export function requireRole(context: GraphQLContext, allowedRoles: RoleEnum[]): void {
  if (!context.user) {
    throw new Error("No autorizado");
  }
  if (!allowedRoles.includes(context.user.role)) {
    throw new Error("Permiso insuficiente");
  }
}

/**
 * Validates that the user is authenticated
 * @param context GraphQL context containing user information
 * @throws Error if user is not authenticated
 */
export function requireAuth(context: GraphQLContext): void {
  if (!context.user) {
    throw new Error("No autorizado");
  }
}

/**
 * Checks if user has admin privileges (MANAGER or SUPERADMIN)
 * @param context GraphQL context containing user information
 * @returns true if user is admin, false otherwise
 */
export function isAdmin(context: GraphQLContext): boolean {
  return context.user?.role === RoleEnum.MANAGER || context.user?.role === RoleEnum.SUPERADMIN;
}

/**
 * Validates that the user has admin privileges
 * @param context GraphQL context containing user information
 * @throws Error if user is not authenticated or not an admin
 */
export function requireAdmin(context: GraphQLContext): void {
  requireAuth(context);
  if (!isAdmin(context)) {
    throw new Error("Permiso insuficiente - se requieren privilegios de administrador");
  }
}
</file>

<file path="backend/interfaces/graphql/pubsub.ts">
import { PubSub } from 'graphql-subscriptions';

// Create a singleton PubSub instance
export const pubsub = new PubSub();

// Define subscription events
export const SUBSCRIPTION_EVENTS = {
  ORDER_CREATED: 'ORDER_CREATED',
  ORDER_UPDATED: 'ORDER_UPDATED',
  ORDER_STATUS_CHANGED: 'ORDER_STATUS_CHANGED',
} as const;
</file>

<file path="backend/.gitignore">
/node_modules
/dist
.env
.DS_Store
.bin
backend/node_modules
/.env
/.DS_Store
/.bin
/.vscode
/.idea
</file>

<file path="backend/README.md">
# Proyecto Restaurantes – Backend

Este repositorio contiene el backend mínimo para:
- Autenticación/Autorización (signup, login, JWT)  
- Listar menú, crear pedidos, procesar pagos  
- API GraphQL con Node.js + Express + Prisma + PostgreSQL  

## Cómo arrancar

1. Copiar `backend/prisma/.env.example` a `backend/prisma/.env` y ajustar variables.  
2. `cd backend`  
3. `npm install`  
4. `npx prisma generate`  
5. `npx prisma migrate dev --name init`  
6. `npm run dev`
</file>

<file path="frontend-nextjs/public/file.svg">
<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>
</file>

<file path="frontend-nextjs/public/globe.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>
</file>

<file path="frontend-nextjs/public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
</file>

<file path="frontend-nextjs/public/vercel.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>
</file>

<file path="frontend-nextjs/public/window.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>
</file>

<file path="frontend-nextjs/src/app/globals.css">
@import "tailwindcss";

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  background: var(--background);
  color: var(--foreground);
  font-family: Arial, Helvetica, sans-serif;
}
</file>

<file path="frontend-nextjs/src/app/layout.tsx">
import type { Metadata } from "next";
import "./globals.css";
import ClientProvider from "./client-provider";

export const metadata: Metadata = {
  title: "Sistema de Restaurante",
  description: "Sistema de gestión para restaurantes con Next.js y GraphQL",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="es">
      <body className="antialiased">
        <ClientProvider>{children}</ClientProvider>
      </body>
    </html>
  );
}
</file>

<file path="frontend-nextjs/src/components/ui/Card.tsx">
import React from 'react';

interface CardProps {
  children: React.ReactNode;
  className?: string;
  padding?: 'sm' | 'md' | 'lg';
}

interface CardHeaderProps {
  children: React.ReactNode;
  className?: string;
}

interface CardContentProps {
  children: React.ReactNode;
  className?: string;
}

const getPaddingClasses = (padding: 'sm' | 'md' | 'lg'): string => {
  const paddingMap = {
    sm: 'px-3 py-4',
    md: 'px-4 py-5 sm:p-6',
    lg: 'px-6 py-8',
  };
  return paddingMap[padding];
};

export const Card: React.FC<CardProps> = ({ 
  children, 
  className = '', 
  padding = 'md' 
}) => {
  const baseClasses = 'bg-white overflow-hidden shadow rounded-lg';
  const paddingClasses = getPaddingClasses(padding);
  
  return (
    <div className={`${baseClasses} ${className}`.trim()}>
      <div className={paddingClasses}>
        {children}
      </div>
    </div>
  );
};

export const CardHeader: React.FC<CardHeaderProps> = ({ 
  children, 
  className = '' 
}) => {
  return (
    <div className={`mb-4 ${className}`.trim()}>
      {children}
    </div>
  );
};

export const CardContent: React.FC<CardContentProps> = ({ 
  children, 
  className = '' 
}) => {
  return (
    <div className={className}>
      {children}
    </div>
  );
};
</file>

<file path="frontend-nextjs/src/components/ui/index.ts">
export { Button } from './Button';
export type { ButtonVariant, ButtonSize } from './Button';

export { Input } from './Input';
export type { InputType } from './Input';

export { Card, CardHeader, CardContent } from './Card';

export { Badge, getStatusBadgeVariant } from './Badge';
export type { BadgeVariant, BadgeSize } from './Badge';
</file>

<file path="frontend-nextjs/src/hooks/useDashboardUtils.ts">
import type { ApolloError } from '@apollo/client';
import { RoleEnum } from '../types';

// Error types
interface GraphQLError {
  message: string;
}

interface NetworkError {
  message: string;
}

interface ErrorWithDetails {
  networkError?: NetworkError;
  graphQLErrors?: GraphQLError[];
  message?: string;
}

export const useDashboardUtils = (userData: any) => {
  // Helper function to get detailed error message
  const getErrorMessage = (error: ErrorWithDetails | ApolloError) => {
    if (error?.networkError) {
      if (error.networkError.message.includes('Failed to fetch')) {
        return 'No se puede conectar al servidor backend. Asegúrate de que el backend esté ejecutándose en http://localhost:4000/graphql';
      }
      return `Error de conexión: ${error.networkError.message}`;
    }
    if (error?.graphQLErrors?.length && error.graphQLErrors.length > 0) {
      return error.graphQLErrors.map((err: GraphQLError) => err.message).join(', ');
    }
    return error?.message || 'Error desconocido';
  };

  // Check if we have connection issues
  const hasConnectionIssues = (menuError?: ApolloError, tablesError?: ApolloError, ordersError?: ApolloError) => {
    return (menuError?.networkError || tablesError?.networkError || ordersError?.networkError) && 
      [menuError, tablesError, ordersError].some(error => 
        error?.networkError?.message?.includes('Failed to fetch')
      );
  };

  // QR Code URL generator
  const getQrCodeUrl = (qrCode: string) => {
    const baseUrl = window.location.origin;
    return `${baseUrl}/menu/${qrCode}`;
  };

  // Price formatter
  const formatPrice = (price: number) => {
    return new Intl.NumberFormat('es-CO', {
      style: 'currency',
      currency: 'COP',
      minimumFractionDigits: 0
    }).format(price);
  };

  // Permission checkers
  const canManageMenu = userData?.me.role === RoleEnum.MANAGER || userData?.me.role === RoleEnum.SUPERADMIN;
  const canManageTables = userData?.me.role !== undefined;

  return {
    getErrorMessage,
    hasConnectionIssues,
    getQrCodeUrl,
    formatPrice,
    canManageMenu,
    canManageTables
  };
};
</file>

<file path="frontend-nextjs/src/lib/styles.ts">
// Common layout utilities and patterns
export const GRID_LAYOUTS = {
  single: 'grid grid-cols-1 gap-6',
  twoCol: 'grid grid-cols-1 gap-6 sm:grid-cols-2',
  threeCol: 'grid grid-cols-1 gap-6 sm:grid-cols-2 lg:grid-cols-3',
  fourCol: 'grid grid-cols-1 gap-6 sm:grid-cols-2 lg:grid-cols-4',
  responsive: 'grid grid-cols-1 gap-4 sm:grid-cols-2',
  responsiveFilters: 'grid grid-cols-1 gap-4 sm:grid-cols-2 lg:grid-cols-3 mb-4',
  responsiveOrderFilters: 'grid grid-cols-1 gap-4 sm:grid-cols-2 lg:grid-cols-4 mb-4',
} as const;

export const SPACING = {
  section: 'mb-6',
  header: 'mb-4',
  content: 'mb-2',
  button: 'mt-4',
  form: 'mt-6',
} as const;

export const CONTAINER = {
  maxWidth: 'max-w-7xl mx-auto',
  padding: 'px-4 sm:px-6 lg:px-8',
  section: 'px-4 py-6 sm:px-0',
} as const;

export const FLEX = {
  between: 'flex justify-between items-center',
  center: 'flex justify-center items-center',
  spaceBetween: 'flex justify-between',
  spaceAround: 'flex justify-around',
  wrap: 'flex flex-wrap gap-2',
  column: 'flex flex-col',
} as const;

export const TEXT = {
  heading1: 'text-3xl font-bold text-gray-900',
  heading2: 'text-2xl font-bold text-gray-900',
  heading3: 'text-lg font-medium text-gray-900',
  heading4: 'text-sm font-medium text-gray-900',
  body: 'text-gray-600',
  small: 'text-sm text-gray-600',
  error: 'text-red-700',
} as const;

export const TRANSITIONS = {
  default: 'transition-colors duration-200',
  fast: 'transition-colors duration-150',
  slow: 'transition-colors duration-300',
} as const;

// Utility function to combine class names
export const cn = (...classes: (string | undefined | null | false)[]): string => {
  return classes.filter(Boolean).join(' ');
};
</file>

<file path="frontend-nextjs/.gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path="frontend-nextjs/eslint.config.mjs">
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
];

export default eslintConfig;
</file>

<file path="frontend-nextjs/next.config.ts">
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;
</file>

<file path="frontend-nextjs/package.json">
{
  "name": "frontend-nextjs",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@apollo/client": "^3.13.8",
    "graphql": "^16.11.0",
    "graphql-ws": "^6.0.5",
    "next": "15.3.3",
    "react": "^19.0.0",
    "react-dom": "^19.0.0"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "15.3.3",
    "tailwindcss": "^4",
    "typescript": "^5"
  }
}
</file>

<file path="frontend-nextjs/postcss.config.mjs">
const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;
</file>

<file path="frontend-nextjs/README.md">
# Frontend Next.js - Sistema de Restaurante

Esta es la versión migrada a Next.js del frontend del sistema de restaurante. Mantiene toda la funcionalidad original del frontend React pero aprovecha las ventajas de Next.js.

## Características

- **Framework**: Next.js 15 con App Router
- **Estilo**: Tailwind CSS para diseño responsivo
- **GraphQL**: Apollo Client para comunicación con el backend
- **TypeScript**: Tipado estático completo
- **Autenticación**: JWT con localStorage
- **Roles**: Soporte para SUPERADMIN, MANAGER y STAFF

## Funcionalidades

### Autenticación
- Login y registro de usuarios
- Botones de acceso rápido para usuarios de prueba
- Manejo de tokens JWT

### Gestión de Menú
- Ver todos los items del menú
- Crear nuevos platos (solo Manager/Admin)
- Eliminar items (solo Manager/Admin)
- Visualización de precios en formato colombiano

### Gestión de Mesas
- Ver todas las mesas del restaurante
- Agregar/eliminar mesas
- Ver pedidos activos por mesa
- Crear pedidos rápidos desde las mesas

### Gestión de Pedidos
- Ver todos los pedidos del sistema
- Cambiar estados de pedidos (Pendiente → Preparando → Listo)
- Procesar pagos
- Vista detallada por mesa y general

## Instalación

1. Asegúrate de que el backend esté corriendo en `http://localhost:4000/graphql`

2. Instala las dependencias:
```bash
npm install
```

3. Ejecuta en modo desarrollo:
```bash
npm run dev
```

4. Abre [http://localhost:3000](http://localhost:3000) en tu navegador

## Scripts Disponibles

- `npm run dev` - Ejecuta en modo desarrollo con Turbopack
- `npm run build` - Construye la aplicación para producción
- `npm run start` - Ejecuta la aplicación en modo producción
- `npm run lint` - Ejecuta el linter de código

## Usuarios de Prueba

Puedes usar estos usuarios pre-configurados para probar la aplicación:

- **Admin**: admin@food360.local / 123456
- **Manager**: manager@food360.local / manager  
- **Staff**: staff@food360.local / staff

## Diferencias con la Versión React

### Ventajas de Next.js
- **Server-Side Rendering (SSR)**: Mejor SEO y performance inicial
- **App Router**: Estructura de rutas más moderna y flexible
- **Optimizaciones automáticas**: Compresión de imágenes, code splitting, etc.
- **Tailwind CSS**: Diseño más moderno y responsivo
- **TypeScript mejorado**: Mejor integración con Next.js

### Estructura de Archivos
```
src/
├── app/
│   ├── layout.tsx          # Layout principal
│   ├── page.tsx           # Página principal
│   └── globals.css        # Estilos globales
├── components/
│   ├── Auth.tsx           # Componente de autenticación
│   └── Dashboard.tsx      # Dashboard principal
├── lib/
│   ├── apollo-client.ts   # Configuración Apollo Client
│   ├── apollo-provider.tsx # Provider para Apollo
│   └── queries.ts         # Queries y mutaciones GraphQL
└── types.ts               # Tipos TypeScript
```

## Configuración del Backend

Esta aplicación requiere que el backend GraphQL esté ejecutándose. Asegúrate de:

1. Tener el backend corriendo en `http://localhost:4000/graphql`
2. La base de datos PostgreSQL configurada
3. Los datos de seed cargados para los usuarios de prueba

## Tecnologías Utilizadas

- **Next.js 15**: Framework React con SSR
- **React 19**: Biblioteca de interfaz de usuario
- **TypeScript**: Superset tipado de JavaScript
- **Tailwind CSS**: Framework de CSS utilitario
- **Apollo Client**: Cliente GraphQL
- **GraphQL**: Lenguaje de consulta para APIs

## Próximos Pasos

Esta migración mantiene toda la funcionalidad del frontend React original. Posibles mejoras futuras:

- Implementar rutas protegidas con middleware de Next.js
- Agregar Server-Side Rendering para mejor SEO
- Implementar cache de Apollo con persistencia
- Agregar Progressive Web App (PWA) capabilities
- Implementar notificaciones en tiempo real
</file>

<file path="frontend-nextjs/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="scripts/build.sh">
#!/bin/bash

# Build script - builds both frontend and backend for production

set -e

echo "🔨 Building applications for production..."

# Colors for output
GREEN='\033[0;32m'
BLUE='\033[0;34m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Function to handle errors
handle_error() {
    echo -e "${RED}❌ Build failed at: $1${NC}"
    exit 1
}

# Check if dependencies are installed
if [ ! -d "backend/node_modules" ] || [ ! -d "frontend-nextjs/node_modules" ]; then
    echo -e "${YELLOW}Dependencies not found. Installing...${NC}"
    make install || handle_error "dependency installation"
fi

# Build backend
echo -e "${BLUE}Building backend...${NC}"
cd backend
npm run generate || handle_error "backend prisma generate"
# Add TypeScript compilation if needed
if [ -f "tsconfig.json" ]; then
    npx tsc || handle_error "backend TypeScript compilation"
fi
cd ..

# Build frontend
echo -e "${GREEN}Building frontend...${NC}"
cd frontend-nextjs
npm run build || handle_error "frontend build"
cd ..

echo -e "${GREEN}✅ Build completed successfully!${NC}"
echo -e "${GREEN}Backend: Ready for deployment${NC}"
echo -e "${GREEN}Frontend: Built to .next directory${NC}"
</file>

<file path="scripts/deploy.sh">
#!/bin/bash

# Deploy script - deploys both applications locally in production mode

set -e

echo "🚀 Deploying applications locally..."

# Colors for output
GREEN='\033[0;32m'
BLUE='\033[0;34m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Configuration
BACKEND_PORT=4000
FRONTEND_PORT=3000
LOG_DIR="logs"

# Create logs directory
mkdir -p $LOG_DIR

# Function to cleanup processes on exit
cleanup() {
    echo -e "\n${YELLOW}Shutting down deployed services...${NC}"
    if [ ! -z "$BACKEND_PID" ]; then
        kill $BACKEND_PID 2>/dev/null || true
    fi
    if [ ! -z "$FRONTEND_PID" ]; then
        kill $FRONTEND_PID 2>/dev/null || true
    fi
    exit 0
}

# Set up signal handlers
trap cleanup SIGINT SIGTERM

# Check if applications are built
if [ ! -d "frontend-nextjs/.next" ]; then
    echo -e "${YELLOW}Frontend not built. Building now...${NC}"
    make build
fi

# Stop any existing processes on the ports
echo -e "${BLUE}Stopping existing services...${NC}"
lsof -ti:$BACKEND_PORT | xargs kill -9 2>/dev/null || true
lsof -ti:$FRONTEND_PORT | xargs kill -9 2>/dev/null || true

# Start backend in production mode
echo -e "${BLUE}Starting backend in production mode...${NC}"
cd backend
NODE_ENV=production npm run dev > ../$LOG_DIR/backend.log 2>&1 &
BACKEND_PID=$!
cd ..

# Wait for backend to start
sleep 5

# Start frontend in production mode
echo -e "${GREEN}Starting frontend in production mode...${NC}"
cd frontend-nextjs
NODE_ENV=production npm start > ../$LOG_DIR/frontend.log 2>&1 &
FRONTEND_PID=$!
cd ..

# Wait for frontend to start
sleep 3

# Check if services are running
if kill -0 $BACKEND_PID 2>/dev/null && kill -0 $FRONTEND_PID 2>/dev/null; then
    echo -e "${GREEN}✅ Deployment successful!${NC}"
    echo -e "${GREEN}Backend:  http://localhost:$BACKEND_PORT${NC}"
    echo -e "${GREEN}Frontend: http://localhost:$FRONTEND_PORT${NC}"
    echo -e "${BLUE}Logs available in: $LOG_DIR/${NC}"
    echo -e "${YELLOW}Press Ctrl+C to stop services${NC}"
    
    # Wait for processes
    wait
else
    echo -e "${RED}❌ Deployment failed!${NC}"
    echo -e "${YELLOW}Check logs in $LOG_DIR/ for details${NC}"
    cleanup
fi
</file>

<file path="scripts/dev.sh">
#!/bin/bash

# Development script - starts both frontend and backend in development mode

set -e

echo "🚀 Starting development environment..."

# Colors for output
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Function to cleanup processes on exit
cleanup() {
    echo -e "\n${YELLOW}Shutting down development servers...${NC}"
    if [ ! -z "$BACKEND_PID" ]; then
        kill $BACKEND_PID 2>/dev/null || true
    fi
    if [ ! -z "$FRONTEND_PID" ]; then
        kill $FRONTEND_PID 2>/dev/null || true
    fi
    exit 0
}

# Set up signal handlers
trap cleanup SIGINT SIGTERM

# Check if dependencies are installed
if [ ! -d "backend/node_modules" ] || [ ! -d "frontend-nextjs/node_modules" ]; then
    echo -e "${YELLOW}Dependencies not found. Installing...${NC}"
    make install
fi

# Start backend in background
echo -e "${BLUE}Starting backend server...${NC}"
cd backend
npm run dev &
BACKEND_PID=$!
cd ..

# Wait a moment for backend to start
sleep 3

# Start frontend in background
echo -e "${GREEN}Starting frontend server...${NC}"
cd frontend-nextjs
npm run dev &
FRONTEND_PID=$!
cd ..

echo -e "${GREEN}✅ Development servers started!${NC}"
echo -e "${GREEN}Backend:  http://localhost:4000${NC}"
echo -e "${GREEN}Frontend: http://localhost:3000${NC}"
echo -e "${YELLOW}Press Ctrl+C to stop both servers${NC}"

# Wait for processes
wait
</file>

<file path="scripts/logs.sh">
#!/bin/bash

# Logs script - displays logs from running services

echo "📋 Application Logs"

# Colors for output
GREEN='\033[0;32m'
BLUE='\033[0;34m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Configuration
LOG_DIR="logs"

# Function to display usage
show_usage() {
    echo "Usage: $0 [backend|frontend|all] [lines]"
    echo "  backend  - Show backend logs only"
    echo "  frontend - Show frontend logs only"
    echo "  all      - Show all logs (default)"
    echo "  lines    - Number of lines to show (default: 50)"
    echo ""
    echo "Examples:"
    echo "  $0                    # Show last 50 lines of all logs"
    echo "  $0 backend           # Show last 50 lines of backend logs"
    echo "  $0 frontend 100      # Show last 100 lines of frontend logs"
}

# Parse arguments
SERVICE=${1:-all}
LINES=${2:-50}

# Validate arguments
if [[ "$SERVICE" != "backend" && "$SERVICE" != "frontend" && "$SERVICE" != "all" ]]; then
    echo -e "${RED}Invalid service: $SERVICE${NC}"
    show_usage
    exit 1
fi

# Check if logs directory exists
if [ ! -d "$LOG_DIR" ]; then
    echo -e "${YELLOW}⚠️  Log directory not found. No services have been deployed yet.${NC}"
    echo -e "${BLUE}Run 'make deploy' to start services and generate logs.${NC}"
    exit 1
fi

# Function to show log file
show_log() {
    local service=$1
    local log_file="$LOG_DIR/${service}.log"
    
    if [ -f "$log_file" ]; then
        echo -e "\n${BLUE}=== $service Logs (Last $LINES lines) ===${NC}"
        tail -n "$LINES" "$log_file"
    else
        echo -e "\n${YELLOW}⚠️  $service log file not found: $log_file${NC}"
    fi
}

# Show logs based on service selection
case $SERVICE in
    "backend")
        show_log "backend"
        ;;
    "frontend")
        show_log "frontend"
        ;;
    "all")
        show_log "backend"
        show_log "frontend"
        ;;
esac

# Show real-time logs option
echo -e "\n${BLUE}💡 Tip: For real-time logs, use:${NC}"
if [ "$SERVICE" = "backend" ] || [ "$SERVICE" = "all" ]; then
    echo -e "${GREEN}  tail -f $LOG_DIR/backend.log${NC}"
fi
if [ "$SERVICE" = "frontend" ] || [ "$SERVICE" = "all" ]; then
    echo -e "${GREEN}  tail -f $LOG_DIR/frontend.log${NC}"
fi
</file>

<file path="scripts/status.sh">
#!/bin/bash

# Status script - checks the status of running services

echo "📊 Checking service status..."

# Colors for output
GREEN='\033[0;32m'
BLUE='\033[0;34m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Configuration
BACKEND_PORT=4000
FRONTEND_PORT=3000

echo -e "${BLUE}Service Status Report${NC}"
echo "=========================="

# Check backend status
echo -e "\n${BLUE}Backend (Port $BACKEND_PORT):${NC}"
if lsof -i:$BACKEND_PORT > /dev/null 2>&1; then
    PID=$(lsof -ti:$BACKEND_PORT)
    echo -e "${GREEN}✅ Running (PID: $PID)${NC}"
    PROCESS_INFO=$(ps -p $PID -o pid,ppid,cmd --no-headers 2>/dev/null || echo "Process info unavailable")
    echo "   $PROCESS_INFO"
else
    echo -e "${RED}❌ Not running${NC}"
fi

# Check frontend status
echo -e "\n${BLUE}Frontend (Port $FRONTEND_PORT):${NC}"
if lsof -i:$FRONTEND_PORT > /dev/null 2>&1; then
    PID=$(lsof -ti:$FRONTEND_PORT)
    echo -e "${GREEN}✅ Running (PID: $PID)${NC}"
    PROCESS_INFO=$(ps -p $PID -o pid,ppid,cmd --no-headers 2>/dev/null || echo "Process info unavailable")
    echo "   $PROCESS_INFO"
else
    echo -e "${RED}❌ Not running${NC}"
fi

# Check database connectivity (if applicable)
echo -e "\n${BLUE}Database:${NC}"
if [ -f "backend/.env" ] && cd backend && npm run generate > /dev/null 2>&1; then
    echo -e "${GREEN}✅ Database accessible${NC}"
    cd ..
else
    echo -e "${YELLOW}⚠️  Database status unknown${NC}"
fi

# Check log files
echo -e "\n${BLUE}Log Files:${NC}"
if [ -d "logs" ]; then
    for log in logs/*.log; do
        if [ -f "$log" ]; then
            SIZE=$(du -h "$log" | cut -f1)
            MODIFIED=$(stat -f "%Sm" -t "%Y-%m-%d %H:%M:%S" "$log" 2>/dev/null || echo "Unknown")
            echo -e "${GREEN}📄 $log${NC} (Size: $SIZE, Modified: $MODIFIED)"
        fi
    done
else
    echo -e "${YELLOW}⚠️  No log directory found${NC}"
fi

echo -e "\n${BLUE}System Resources:${NC}"
echo "CPU Usage: $(top -l 1 -s 0 | grep "CPU usage" | awk '{print $3}' | cut -d% -f1)%"
echo "Memory: $(top -l 1 -s 0 | grep "PhysMem" | awk '{print $2 " used, " $6 " free"}')"
</file>

<file path="scripts/test.sh">
#!/bin/bash

# Test script - runs linting and tests for both frontend and backend

set -e

echo "🧪 Running tests and linting..."

# Colors for output
GREEN='\033[0;32m'
BLUE='\033[0;34m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Track test results
BACKEND_LINT_PASSED=0
FRONTEND_LINT_PASSED=0
TESTS_PASSED=0

# Function to handle test results
handle_test_result() {
    if [ $1 -eq 0 ]; then
        echo -e "${GREEN}✅ $2 passed${NC}"
        return 0
    else
        echo -e "${RED}❌ $2 failed${NC}"
        return 1
    fi
}

# Check if dependencies are installed
if [ ! -d "backend/node_modules" ] || [ ! -d "frontend-nextjs/node_modules" ]; then
    echo -e "${YELLOW}Dependencies not found. Installing...${NC}"
    make install
fi

# Test backend
echo -e "${BLUE}Running backend linting...${NC}"
cd backend
if npm run lint; then
    BACKEND_LINT_PASSED=1
    handle_test_result 0 "Backend linting"
else
    handle_test_result 1 "Backend linting"
fi
cd ..

# Test frontend
echo -e "${GREEN}Running frontend linting...${NC}"
cd frontend-nextjs
if npm run lint; then
    FRONTEND_LINT_PASSED=1
    handle_test_result 0 "Frontend linting"
else
    handle_test_result 1 "Frontend linting"
fi
cd ..

# Summary
echo -e "\n${BLUE}Test Summary:${NC}"
if [ $BACKEND_LINT_PASSED -eq 1 ] && [ $FRONTEND_LINT_PASSED -eq 1 ]; then
    echo -e "${GREEN}✅ All tests passed!${NC}"
    exit 0
else
    echo -e "${RED}❌ Some tests failed${NC}"
    exit 1
fi
</file>

<file path="CI-CD-README.md">
# 🍽️ Proyecto Restaurantes - Local CI/CD Pipeline

A simple and effective local CI/CD pipeline for developing and deploying the restaurant management system.

## 📁 Project Structure

```
proyecto-restaurantes/
├── backend/                 # GraphQL API with Prisma
├── frontend-nextjs/         # Next.js React frontend
├── scripts/                 # CI/CD pipeline scripts
├── logs/                   # Application logs (created on deploy)
└── Makefile                # Main pipeline commands
```

## 🚀 Quick Start

### Prerequisites
- Node.js (v18+)
- npm
- Make (comes with macOS)

### Initial Setup
```bash
# Clone and enter the project
cd proyecto-restaurantes

# Install dependencies and setup database
make install
make db-setup

# Start development environment
make dev
```

## 📋 Available Commands

### Main Pipeline Commands
```bash
make help       # Show all available commands
make install    # Install dependencies for both apps
make dev        # Start development servers
make build      # Build both applications
make test       # Run linting and tests
make deploy     # Deploy locally in production mode
make status     # Check service status
make logs       # Show application logs
make clean      # Clean build artifacts
make pipeline   # Run full CI/CD pipeline
```

### Database Commands
```bash
make db-setup   # Setup database and run migrations
make db-reset   # Reset database (development only)
```

## 🔧 Development Workflow

### 1. Start Development
```bash
make dev
```
- Backend: http://localhost:4000
- Frontend: http://localhost:3000
- Both servers restart automatically on code changes

### 2. Run Tests
```bash
make test
```
- Runs ESLint on both frontend and backend
- Checks for code quality issues

### 3. Build for Production
```bash
make build
```
- Compiles TypeScript
- Generates Prisma client
- Builds Next.js application

### 4. Deploy Locally
```bash
make deploy
```
- Runs applications in production mode
- Logs output to `logs/` directory
- Services run in background

## 📊 Monitoring

### Check Service Status
```bash
make status
```
Shows:
- Running processes and PIDs
- Port usage
- Database connectivity
- Log file information
- System resources

### View Logs
```bash
make logs                    # Show all logs (last 50 lines)
./scripts/logs.sh backend    # Backend logs only
./scripts/logs.sh frontend 100  # Frontend logs (last 100 lines)
```

### Real-time Log Monitoring
```bash
tail -f logs/backend.log     # Follow backend logs
tail -f logs/frontend.log    # Follow frontend logs
```

## 🛠️ CI/CD Pipeline Scripts

### Individual Scripts
```bash
./scripts/dev.sh       # Development server startup
./scripts/build.sh     # Production build
./scripts/test.sh      # Testing and linting
./scripts/deploy.sh    # Local deployment
./scripts/status.sh    # Service status check
./scripts/logs.sh      # Log viewing
```

## 🔄 Full Pipeline Example

```bash
# Complete CI/CD pipeline
make pipeline

# This runs:
# 1. make clean      - Clean previous builds
# 2. make install    - Install dependencies
# 3. make db-setup   - Setup database
# 4. make test       - Run tests and linting
# 5. make build      - Build applications
# 6. make deploy     - Deploy locally
```

## 📁 Generated Files and Directories

### Logs Directory
```
logs/
├── backend.log      # Backend application logs
└── frontend.log     # Frontend application logs
```

### Build Artifacts
```
backend/
└── dist/           # Compiled TypeScript (if configured)

frontend-nextjs/
├── .next/          # Next.js build output
└── out/            # Static export (if configured)
```

## 🚨 Troubleshooting

### Port Already in Use
```bash
# Check what's using the ports
lsof -i:3000  # Frontend port
lsof -i:4000  # Backend port

# Kill processes if needed
make status   # Check current status first
```

### Database Issues
```bash
# Reset database completely
make db-reset

# Regenerate Prisma client
cd backend && npm run generate
```

### Build Failures
```bash
# Clean and rebuild
make clean
make install
make build
```

### View Detailed Logs
```bash
# Check specific service logs
./scripts/logs.sh backend 200   # Last 200 lines of backend
./scripts/logs.sh frontend 100  # Last 100 lines of frontend
```

## 🎯 Best Practices

### Development
1. Always run `make test` before committing
2. Use `make dev` for development work
3. Check `make status` if services seem unresponsive

### Deployment
1. Run `make build` to verify builds work
2. Use `make deploy` for local production testing
3. Monitor logs with `make logs` after deployment

### Debugging
1. Check service status first: `make status`
2. Review logs: `make logs`
3. For real-time debugging: `tail -f logs/backend.log`

## 🔧 Configuration

### Environment Variables
- Backend: Create `backend/.env` for database and API configuration
- Frontend: Create `frontend-nextjs/.env.local` for client configuration

### Ports
- Backend: 4000 (configurable in scripts)
- Frontend: 3000 (configurable in scripts)

## 📝 Notes

- This pipeline is designed for local development and testing
- For production deployment, consider using Docker or cloud platforms
- Logs are rotated manually - clean them periodically
- All scripts include error handling and colored output for better UX

## 🤝 Contributing

1. Make changes to your code
2. Run `make test` to ensure quality
3. Use `make pipeline` to test the full flow
4. Commit your changes

---

**Happy coding! 🚀**
</file>

<file path="Makefile">
# Proyecto Restaurantes - Local CI/CD Pipeline
# Simple Makefile for local development and deployment

.PHONY: help install dev build test deploy clean status logs

# Default target
help:
	@echo "🍽️  Proyecto Restaurantes - Local CI/CD Pipeline"
	@echo ""
	@echo "Available commands:"
	@echo "  install     - Install dependencies for both frontend and backend"
	@echo "  dev         - Start development servers (frontend & backend)"
	@echo "  build       - Build both applications"
	@echo "  test        - Run tests and linting"
	@echo "  deploy      - Deploy both applications locally"
	@echo "  status      - Check status of running services"
	@echo "  logs        - Show logs from running services"
	@echo "  clean       - Clean build artifacts and node_modules"
	@echo "  db-setup    - Setup database and run migrations"
	@echo "  db-reset    - Reset database"
	@echo ""

# Install dependencies
install:
	@echo "📦 Installing dependencies..."
	@cd backend && npm install
	@cd frontend-nextjs && npm install
	@echo "✅ Dependencies installed successfully"

# Database setup
db-setup:
	@echo "🗄️  Setting up database..."
	@cd backend && npm run generate
	@cd backend && npm run migrate
	@echo "✅ Database setup completed"

# Database reset
db-reset:
	@echo "🔄 Resetting database..."
	@cd backend && npx prisma migrate reset --force --schema=./infrastructure/prisma/schema.prisma
	@echo "✅ Database reset completed"

# Development mode
dev:
	@echo "🚀 Starting development servers..."
	@./scripts/dev.sh

# Build applications
build:
	@echo "🔨 Building applications..."
	@./scripts/build.sh

# Run tests and linting
test:
	@echo "🧪 Running tests and linting..."
	@./scripts/test.sh

# Deploy locally
deploy:
	@echo "🚀 Deploying applications locally..."
	@./scripts/deploy.sh

# Check status
status:
	@echo "📊 Checking service status..."
	@./scripts/status.sh

# Show logs
logs:
	@echo "📋 Showing application logs..."
	@./scripts/logs.sh

# Clean build artifacts
clean:
	@echo "🧹 Cleaning build artifacts..."
	@rm -rf backend/node_modules backend/dist
	@rm -rf frontend-nextjs/node_modules frontend-nextjs/.next frontend-nextjs/out
	@echo "✅ Clean completed"

# Full pipeline
pipeline: clean install db-setup test build deploy
	@echo "🎉 Full pipeline completed successfully!"
</file>

<file path="backend/application/interfaces/IMenuItemRepository.ts">
import { MenuItem } from "../../domain/entities/MenuItem";
import { Connection, Cursor } from "../../domain/valueObjects/Pagination";

export interface MenuItemFilter {
  name?: string;
  priceMin?: number;
  priceMax?: number;
  isAvailable?: boolean;
}

export interface MenuItemSort {
  field: "id" | "name" | "price" | "createdAt" | "isAvailable";
  order: "asc" | "desc";
}

export interface IMenuItemRepository {
  findById(id: number): Promise<MenuItem | null>;
  findBySku(sku: string): Promise<MenuItem | null>;
  findMany(
    filter?: MenuItemFilter,
    sort?: MenuItemSort,
    first?: number,
    after?: Cursor,
  ): Promise<Connection<MenuItem>>;
  create(menuItemData: {
    sku: string;
    name: string;
    price: number;
    isAvailable?: boolean;
  }): Promise<MenuItem>;
  update(id: number, menuItemData: Partial<MenuItem>): Promise<MenuItem>;
  delete(id: number): Promise<void>;
  count(filter?: MenuItemFilter): Promise<number>;
  findManyWithPagination(
    filter?: MenuItemFilter,
    sort?: MenuItemSort,
    limit?: number,
    offset?: number,
  ): Promise<MenuItem[]>;
}
</file>

<file path="backend/application/interfaces/IOrderRepository.ts">
import { Order, OrderItem, OrderStatus } from "../../domain/entities/Order";
import { Connection, Cursor } from "../../domain/valueObjects/Pagination";

export interface OrderFilter {
  status?: OrderStatus;
  tableId?: number;
  userId?: number;
  createdAfter?: Date;
  createdBefore?: Date;
}

export interface OrderSort {
  field: "id" | "status" | "createdAt" | "tableId";
  order: "asc" | "desc";
}

export interface IOrderRepository {
  findById(id: number): Promise<Order | null>;
  findByTableId(tableId: number): Promise<Order[]>;
  findByQrCode(qrCode: string): Promise<Order[]>;
  findMany(
    filter?: OrderFilter,
    sort?: OrderSort,
    first?: number,
    after?: Cursor,
  ): Promise<Connection<Order>>;
  findManyWithPagination(
    filter?: OrderFilter,
    sort?: OrderSort,
    limit?: number,
    offset?: number,
  ): Promise<Order[]>;
  count(filter?: OrderFilter): Promise<number>;
  create(orderData: {
    status: OrderStatus;
    tableId: number;
    userId: number;
  }): Promise<Order>;
  update(id: number, orderData: Partial<Order>): Promise<Order>;
  delete(id: number): Promise<void>;
  addOrderItem(
    orderId: number,
    orderItemData: {
      menuItemId: number;
      quantity: number;
      price: number;
    },
  ): Promise<OrderItem>;
  updateOrderStatus(id: number, status: OrderStatus): Promise<Order>;
}
</file>

<file path="backend/application/interfaces/ITableRepository.ts">
import { Table } from "../../domain/entities/Table";
import { Connection, Cursor } from "../../domain/valueObjects/Pagination";

export interface TableFilter {
  number?: number;
  capacityMin?: number;
  capacityMax?: number;
  hasQrCode?: boolean;
}

export interface TableSort {
  field: "id" | "number" | "capacity" | "orderCount";
  order: "asc" | "desc";
}

export interface ITableRepository {
  findById(id: number): Promise<Table | null>;
  findByNumber(number: number): Promise<Table | null>;
  findByQrCode(qrCode: string): Promise<Table | null>;
  
  // Overloaded method for different pagination types
  findMany(
    filter?: TableFilter,
    sort?: TableSort,
    first?: number,
    after?: Cursor,
  ): Promise<Connection<Table>>;
  findMany(
    filter?: any,
    sort?: any,
    limit?: number,
    offset?: number,
  ): Promise<Table[]>;
  
  create(tableData: {
    number: number;
    capacity: number;
    qrCode?: string;
  }): Promise<Table>;
  update(id: number, tableData: Partial<Table>): Promise<Table>;
  delete(id: number): Promise<Table>; // Changed to return Table instead of void
  getNextTableNumber(): Promise<number>;
  count(filter?: TableFilter): Promise<number>;
}
</file>

<file path="backend/application/useCases/CreateOrderByQrCode.ts">
import { Order, OrderStatus } from "../../domain/entities/Order";
import { IOrderRepository } from "../interfaces/IOrderRepository";
import { ITableRepository } from "../interfaces/ITableRepository";
import { IMenuItemRepository } from "../interfaces/IMenuItemRepository";
import { IUserRepository } from "../interfaces/IUserRepository";
import { pubsub, SUBSCRIPTION_EVENTS } from "../../interfaces/graphql/pubsub";

export interface CreateOrderByQrCodeRequest {
  qrCode: string;
  items: {
    menuItemId: number;
    quantity: number;
  }[];
}

export class CreateOrderByQrCode {
  constructor(
    private readonly orderRepository: IOrderRepository,
    private readonly tableRepository: ITableRepository,
    private readonly menuItemRepository: IMenuItemRepository,
    private readonly userRepository: IUserRepository,
  ) {}

  async execute(request: CreateOrderByQrCodeRequest): Promise<Order> {
    // Validate table exists by QR code
    const table = await this.tableRepository.findByQrCode(request.qrCode);
    if (!table) {
      throw new Error("Mesa no encontrada");
    }

    // Get or create guest user
    let guestUser = await this.userRepository.findByEmail(
      "guest@restaurant.local",
    );
    if (!guestUser) {
      guestUser = await this.userRepository.create({
        email: "guest@restaurant.local",
        password: await require("bcryptjs").hash("guest", 10),
        role: require("../../domain/entities/User").RoleEnum.STAFF,
      });
    }

    // Create order
    const order = await this.orderRepository.create({
      status: OrderStatus.PENDING,
      tableId: table.id,
      userId: guestUser.id,
    });

    // Add order items
    for (const item of request.items) {
      const menuItem = await this.menuItemRepository.findById(item.menuItemId);
      if (!menuItem) {
        throw new Error(`Menu item with ID ${item.menuItemId} not found`);
      }

      if (!menuItem.isOrderable()) {
        throw new Error(`Menu item ${menuItem.name} is not available`);
      }

      await this.orderRepository.addOrderItem(order.id, {
        menuItemId: item.menuItemId,
        quantity: item.quantity,
        price: menuItem.price,
      });
    }

    // Get the complete order with all items for the response
    const completeOrder = (await this.orderRepository.findById(order.id)) as Order;

    // Publish real-time events for dashboard updates
    pubsub.publish(SUBSCRIPTION_EVENTS.ORDER_CREATED, { orderCreated: completeOrder });
    pubsub.publish(SUBSCRIPTION_EVENTS.ORDER_UPDATED, { orderUpdated: completeOrder });

    return completeOrder;
  }
}
</file>

<file path="backend/application/useCases/UpdateOrderStatus.ts">
import { Order, OrderStatus } from "../../domain/entities/Order";
import { User } from "../../domain/entities/User";
import { IOrderRepository } from "../interfaces/IOrderRepository";
import { pubsub, SUBSCRIPTION_EVENTS } from "../../interfaces/graphql/pubsub";

export interface UpdateOrderStatusRequest {
  orderId: number;
  newStatus: OrderStatus;
  user: User;
}

export class UpdateOrderStatus {
  constructor(private readonly orderRepository: IOrderRepository) {}

  async execute(request: UpdateOrderStatusRequest): Promise<Order> {
    if (!request.user.canManageOrders()) {
      throw new Error("No tienes permisos para actualizar pedidos");
    }

    const order = await this.orderRepository.findById(request.orderId);
    if (!order) {
      throw new Error("Pedido no encontrado");
    }

    const updatedOrder = order.changeStatus(request.newStatus);
    const result = await this.orderRepository.updateOrderStatus(
      request.orderId,
      request.newStatus,
    );

    // Publish real-time events for dashboard updates
    pubsub.publish(SUBSCRIPTION_EVENTS.ORDER_STATUS_CHANGED, { orderStatusChanged: result });
    pubsub.publish(SUBSCRIPTION_EVENTS.ORDER_UPDATED, { orderUpdated: result });

    return result;
  }
}
</file>

<file path="backend/domain/entities/MenuItem.ts">
export class MenuItem {
  constructor(
    public readonly id: number,
    public readonly sku: string,
    public readonly name: string,
    public readonly price: number,
    public readonly imageUrl?: string,
    public readonly isAvailable: boolean = true,
    public readonly createdAt: Date = new Date(),
  ) {}

  public validatePrice(): boolean {
    return this.price > 0;
  }

  public isOrderable(): boolean {
    return this.isAvailable && this.validatePrice();
  }

  public updateAvailability(isAvailable: boolean): MenuItem {
    return new MenuItem(
      this.id,
      this.sku,
      this.name,
      this.price,
      this.imageUrl,
      isAvailable,
      this.createdAt,
    );
  }
}
</file>

<file path="backend/infrastructure/prisma/schema.prisma">
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

enum RoleEnum {
  SUPERADMIN
  MANAGER
  STAFF
}

model User {
  id        Int       @id @default(autoincrement())
  email     String    @unique
  password  String
  role      RoleEnum  @default(STAFF)
  createdAt DateTime  @default(now())
  orders    Order[]

  @@map("users")
}

model Table {
  id        Int     @id @default(autoincrement())
  number    Int     @unique
  capacity  Int     @default(4)
  qrCode    String? @unique
  orders    Order[]

  @@map("tables")
}

model MenuItem {
  id          Int       @id @default(autoincrement())
  sku         String    @unique
  name        String
  price       Decimal   @db.Money
  imageUrl    String?   @default("https://images.unsplash.com/photo-1546833999-b9f581a1996d?w=400&h=300&fit=crop")
  isAvailable Boolean   @default(true)
  createdAt   DateTime  @default(now())
  orderItems  OrderItem[]

  @@map("menu_items")
}

model Order {
  id         Int         @id @default(autoincrement())
  status     String      @default("OPEN")
  tableId    Int
  userId     Int
  createdAt  DateTime    @default(now())
  orderItems OrderItem[]
  payment    Payment?

  table Table @relation(fields: [tableId], references: [id])
  user  User  @relation(fields: [userId], references: [id])

  @@index([status])
  @@map("orders")
}

model OrderItem {
  id         Int     @id @default(autoincrement())
  orderId    Int
  menuItemId Int
  quantity   Int     @default(1)
  price      Decimal  @db.Money

  order    Order    @relation(fields: [orderId], references: [id])
  menuItem MenuItem @relation(fields: [menuItemId], references: [id])

  @@map("order_items")
}

model Payment {
  id        Int      @id @default(autoincrement())
  orderId   Int      @unique
  amount    Decimal  @db.Money
  method    String
  paidAt    DateTime @default(now())

  order Order @relation(fields: [orderId], references: [id])

  @@map("payments")
}
</file>

<file path="backend/infrastructure/prisma/seed.ts">
// prisma/seed.ts
import { PrismaClient, RoleEnum } from "@prisma/client";
import bcrypt from "bcryptjs";

const prisma = new PrismaClient();

async function main() {
  // 1. Limpiar tablas dependientes (mantener idempotencia)
  await prisma.$transaction([
    prisma.payment.deleteMany({}),
    prisma.orderItem.deleteMany({}),
    prisma.order.deleteMany({}),
    prisma.table.deleteMany({}),
    prisma.menuItem.deleteMany({}),
    prisma.user.deleteMany({}),
  ]);

  // 2. Usuarios y roles
  const admin = await prisma.user.create({
    data: {
      email: "admin@food360.local",
      password: await bcrypt.hash("123456", 10), // Properly hash the password
      role: RoleEnum.SUPERADMIN,
    },
  });

  // Create additional users for testing
  await prisma.user.createMany({
    data: [
      {
        email: "manager@food360.local",
        password: await bcrypt.hash("manager", 10),
        role: RoleEnum.MANAGER,
      },
      {
        email: "staff@food360.local",
        password: await bcrypt.hash("staff", 10),
        role: RoleEnum.STAFF,
      },
    ],
  });

  // 3. Mesas
  await prisma.table.createMany({
    data: [
      { number: 1, capacity: 4, qrCode: `table-1-${Date.now()}` },
      { number: 2, capacity: 4, qrCode: `table-2-${Date.now()}` },
      { number: 3, capacity: 6, qrCode: `table-3-${Date.now()}` },
      { number: 4, capacity: 2, qrCode: `table-4-${Date.now()}` },
      { number: 5, capacity: 8, qrCode: `table-5-${Date.now()}` },
      { number: 6, capacity: 4, qrCode: `table-6-${Date.now()}` },
      { number: 7, capacity: 2, qrCode: `table-7-${Date.now()}` },
      { number: 8, capacity: 6, qrCode: `table-8-${Date.now()}` },
      { number: 9, capacity: 4, qrCode: `table-9-${Date.now()}` },
      { number: 10, capacity: 8, qrCode: `table-10-${Date.now()}` },
    ],
  });

  // 4. Menú - Add more variety with stock images
  await prisma.menuItem.createMany({
    data: [
      { 
        sku: "QUESADILLA-CLAS", 
        name: "Quesadilla Clásica", 
        price: 15000,
        imageUrl: "https://images.unsplash.com/photo-1565299624946-b28f40a0ca4b?w=400&h=300&fit=crop"
      },
      { 
        sku: "BURGER-ANGUS", 
        name: "Hamburguesa Angus", 
        price: 28000,
        imageUrl: "https://images.unsplash.com/photo-1568901346375-23c9450c58cd?w=400&h=300&fit=crop"
      },
      { 
        sku: "LIMONADA-MNT", 
        name: "Limonada de Menta", 
        price: 8000,
        imageUrl: "https://images.unsplash.com/photo-1556881286-fc6915169721?w=400&h=300&fit=crop"
      },
      { 
        sku: "TACOS-PASTOR", 
        name: "Tacos al Pastor", 
        price: 18000,
        imageUrl: "https://images.unsplash.com/photo-1565299624946-b28f40a0ca4b?w=400&h=300&fit=crop"
      },
      { 
        sku: "AREPA-QUESO", 
        name: "Arepa con Queso", 
        price: 12000,
        imageUrl: "https://images.unsplash.com/photo-1544025162-d76694265947?w=400&h=300&fit=crop"
      },
      { 
        sku: "CAFE-AMERICANO", 
        name: "Café Americano", 
        price: 5000,
        imageUrl: "https://images.unsplash.com/photo-1497636577773-f1231844b336?w=400&h=300&fit=crop"
      },
      { 
        sku: "CERVEZA-CLUB", 
        name: "Cerveza Club Colombia", 
        price: 7000,
        imageUrl: "https://images.unsplash.com/photo-1608270586620-248524c67de9?w=400&h=300&fit=crop"
      },
      { 
        sku: "BANDEJA-PAISA", 
        name: "Bandeja Paisa", 
        price: 35000,
        imageUrl: "https://images.unsplash.com/photo-1546833999-b9f581a1996d?w=400&h=300&fit=crop"
      },
      { 
        sku: "SALMON-GRILL", 
        name: "Salmón a la Parrilla", 
        price: 32000,
        imageUrl: "https://images.unsplash.com/photo-1467003909585-2f8a72700288?w=400&h=300&fit=crop"
      },
      { 
        sku: "PIZZA-MARG", 
        name: "Pizza Margherita", 
        price: 25000,
        imageUrl: "https://images.unsplash.com/photo-1574071318508-1cdbab80d002?w=400&h=300&fit=crop"
      },
      { 
        sku: "ENSALADA-CAES", 
        name: "Ensalada César", 
        price: 18000,
        imageUrl: "https://images.unsplash.com/photo-1512621776951-a57141f2eefd?w=400&h=300&fit=crop"
      },
      { 
        sku: "PASTA-CARB", 
        name: "Pasta Carbonara", 
        price: 22000,
        imageUrl: "https://images.unsplash.com/photo-1621996346565-e3dbc353d2e5?w=400&h=300&fit=crop"
      }
    ],
  });

  // 5. Pedido demo
  const order = await prisma.order.create({
    data: {
      status: "OPEN",
      table: { connect: { number: 1 } },
      user: { connect: { id: admin.id } },
      orderItems: {
        create: [
          {
            menuItem: { connect: { sku: "BURGER-ANGUS" } },
            quantity: 2,
            price: 28000,
          },
          {
            menuItem: { connect: { sku: "LIMONADA-MNT" } },
            quantity: 2,
            price: 8000,
          },
        ],
      },
    },
  });

  // 6. Pago demo
  await prisma.payment.create({
    data: {
      orderId: order.id,
      amount: 2 * 28000 + 2 * 8000,
      method: "CASH",
    },
  });

  console.log("✅ Seed completed successfully");
  console.log("👤 Test users created:");
  console.log("   - admin@food360.local (password: 123456)");
  console.log("   - manager@food360.local (password: manager)");
  console.log("   - staff@food360.local (password: staff)");
}

main()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
</file>

<file path="backend/infrastructure/repositories/PrismaTableRepository.ts">
import {
  ITableRepository,
  TableFilter,
  TableSort,
} from "../../application/interfaces/ITableRepository";
import { Table } from "../../domain/entities/Table";
import {
  Connection,
  Cursor,
  Edge,
  PaginationInfo,
} from "../../domain/valueObjects/Pagination";
import prisma from "../prisma/client";

export class PrismaTableRepository implements ITableRepository {
  async findById(id: number): Promise<Table | null> {
    const table = await prisma.table.findUnique({
      where: { id },
    });

    if (!table) return null;

    return new Table(
      table.id,
      table.number,
      table.capacity,
      table.qrCode || undefined,
    );
  }

  async findByNumber(number: number): Promise<Table | null> {
    const table = await prisma.table.findUnique({
      where: { number },
    });

    if (!table) return null;

    return new Table(
      table.id,
      table.number,
      table.capacity,
      table.qrCode || undefined,
    );
  }

  async findByQrCode(qrCode: string): Promise<Table | null> {
    const table = await prisma.table.findUnique({
      where: { qrCode },
    });

    if (!table) return null;

    return new Table(
      table.id,
      table.number,
      table.capacity,
      table.qrCode || undefined,
    );
  }

  // Overloaded method to support both cursor and limit/offset pagination
  async findMany(
    filter?: any,
    sort?: any,
    limitOrFirst?: number,
    offsetOrAfter?: number | Cursor,
  ): Promise<any> {
    // If offsetOrAfter is a number, use limit/offset pagination
    if (typeof offsetOrAfter === 'number') {
      return this.findManyWithOffset(filter, sort, limitOrFirst, offsetOrAfter);
    }
    
    // Otherwise use cursor-based pagination
    return this.findManyWithCursor(filter, sort, limitOrFirst, offsetOrAfter);
  }

  private async findManyWithOffset(
    filter?: any,
    sort?: any,
    limit?: number,
    offset?: number,
  ): Promise<Table[]> {
    const where: any = {};

    if (filter) {
      if (filter.number !== undefined) {
        where.number = filter.number;
      }
      if (filter.capacityMin !== undefined || filter.capacityMax !== undefined) {
        where.capacity = {};
        if (filter.capacityMin !== undefined) {
          where.capacity.gte = filter.capacityMin;
        }
        if (filter.capacityMax !== undefined) {
          where.capacity.lte = filter.capacityMax;
        }
      }
      if (filter.hasQrCode !== undefined) {
        where.qrCode = filter.hasQrCode ? { not: null } : null;
      }
    }

    const orderBy: any = {};
    if (sort) {
      if (sort.field === "id" || sort.field === "number" || sort.field === "capacity") {
        orderBy[sort.field] = sort.order;
      } else {
        orderBy.id = "asc";
      }
    } else {
      orderBy.id = "asc";
    }

    const tables = await prisma.table.findMany({
      where,
      orderBy,
      take: limit,
      skip: offset,
    });

    return tables.map((table: any) => new Table(
      table.id,
      table.number,
      table.capacity,
      table.qrCode || undefined,
    ));
  }

  private async findManyWithCursor(
    filter?: TableFilter,
    sort?: TableSort,
    first: number = 10,
    after?: Cursor,
  ): Promise<Connection<Table>> {
    const where: {
      number?: number;
      capacity?: { gte?: number; lte?: number };
      qrCode?: { not: null } | null;
      id?: { gt: number };
    } = {};

    if (filter) {
      if (filter.number !== undefined) {
        where.number = filter.number;
      }
      if (
        filter.capacityMin !== undefined ||
        filter.capacityMax !== undefined
      ) {
        where.capacity = {};
        if (filter.capacityMin !== undefined) {
          where.capacity.gte = filter.capacityMin;
        }
        if (filter.capacityMax !== undefined) {
          where.capacity.lte = filter.capacityMax;
        }
      }
      if (filter.hasQrCode !== undefined) {
        where.qrCode = filter.hasQrCode ? { not: null } : null;
      }
    }

    // Handle cursor-based pagination
    if (after && !after.isEmpty()) {
      where.id = { gt: after.toId() };
    }

    // Handle special ordering for orderCount
    if (sort?.field === "orderCount") {
      const tables = await prisma.table.findMany({
        where,
        take: first + 1,
        include: {
          _count: {
            select: { orders: { where: { status: { not: "PAID" } } } },
          },
        },
      });

      const hasNextPage = tables.length > first;
      const tableList = hasNextPage ? tables.slice(0, -1) : tables;

      // Sort by order count in memory
      const sortedTables = tableList.sort((a, b) => {
        const countA = a._count.orders;
        const countB = b._count.orders;
        return sort.order === "asc" ? countA - countB : countB - countA;
      });

      const edges: Edge<Table>[] = sortedTables.map((table) => ({
        node: new Table(
          table.id,
          table.number,
          table.capacity,
          table.qrCode || undefined,
        ),
        cursor: Cursor.fromId(table.id),
      }));

      const pageInfo = new PaginationInfo(
        hasNextPage,
        !!after && !after.isEmpty(),
        edges.length > 0 ? edges[0].cursor : undefined,
        edges.length > 0 ? edges[edges.length - 1].cursor : undefined,
      );

      return new Connection(edges, pageInfo);
    }

    const orderBy: {
      id?: "asc" | "desc";
      number?: "asc" | "desc";
      capacity?: "asc" | "desc";
    } = {};

    if (sort) {
      if (
        sort.field === "id" ||
        sort.field === "number" ||
        sort.field === "capacity"
      ) {
        orderBy[sort.field] = sort.order;
      } else {
        // Default fallback for any unhandled sort fields
        orderBy.id = "asc";
      }
    } else {
      orderBy.id = "asc";
    }

    const tables = await prisma.table.findMany({
      where,
      orderBy,
      take: first + 1,
    });

    const hasNextPage = tables.length > first;
    const tableList = hasNextPage ? tables.slice(0, -1) : tables;

    const edges: Edge<Table>[] = tableList.map((table) => ({
      node: new Table(
        table.id,
        table.number,
        table.capacity,
        table.qrCode || undefined,
      ),
      cursor: Cursor.fromId(table.id),
    }));

    const pageInfo = new PaginationInfo(
      hasNextPage,
      !!after && !after.isEmpty(),
      edges.length > 0 ? edges[0].cursor : undefined,
      edges.length > 0 ? edges[edges.length - 1].cursor : undefined,
    );

    return new Connection(edges, pageInfo);
  }

  async create(tableData: {
    number: number;
    capacity: number;
    qrCode?: string;
  }): Promise<Table> {
    const table = await prisma.table.create({
      data: {
        number: tableData.number,
        capacity: tableData.capacity,
        qrCode: tableData.qrCode,
      },
    });

    return new Table(
      table.id,
      table.number,
      table.capacity,
      table.qrCode || undefined,
    );
  }

  async update(id: number, tableData: Partial<Table>): Promise<Table> {
    const updateData: {
      number?: number;
      capacity?: number;
      qrCode?: string;
    } = {};
    if (tableData.number !== undefined) updateData.number = tableData.number;
    if (tableData.capacity !== undefined)
      updateData.capacity = tableData.capacity;
    if (tableData.qrCode !== undefined) updateData.qrCode = tableData.qrCode;

    const table = await prisma.table.update({
      where: { id },
      data: updateData,
    });

    return new Table(
      table.id,
      table.number,
      table.capacity,
      table.qrCode || undefined,
    );
  }

  async delete(id: number): Promise<Table> {
    const table = await prisma.table.delete({
      where: { id },
    });

    return new Table(
      table.id,
      table.number,
      table.capacity,
      table.qrCode || undefined,
    );
  }

  async getNextTableNumber(): Promise<number> {
    const lastTable = await prisma.table.findFirst({
      orderBy: { number: "desc" },
    });
    return lastTable ? lastTable.number + 1 : 1;
  }

  async count(filter?: TableFilter): Promise<number> {
    const where: any = {};

    if (filter) {
      if (filter.number !== undefined) {
        where.number = filter.number;
      }
      if (filter.capacityMin !== undefined || filter.capacityMax !== undefined) {
        where.capacity = {};
        if (filter.capacityMin !== undefined) {
          where.capacity.gte = filter.capacityMin;
        }
        if (filter.capacityMax !== undefined) {
          where.capacity.lte = filter.capacityMax;
        }
      }
      if (filter.hasQrCode !== undefined) {
        where.qrCode = filter.hasQrCode ? { not: null } : null;
      }
    }

    return await prisma.table.count({ where });
  }
}
</file>

<file path="backend/interfaces/graphql/resolvers/paymentResolvers.ts">
import { GraphQLContext } from "../context";
import { RoleEnum } from "@prisma/client";
import { requireRole } from "../utils/auth";

export const paymentResolvers = {
  Mutation: {
    createPaymentForOrder: async (
      _: unknown,
      args: { type: string; orderId: string },
      context: GraphQLContext
    ) => {
      requireRole(context, [RoleEnum.STAFF, RoleEnum.MANAGER, RoleEnum.SUPERADMIN]);

      // Get the order to calculate amount
      const order = await context.repositories.orderRepository.findById(Number(args.orderId));
      if (!order) throw new Error("Order not found");

      const amount = order.getTotalAmount();

      // Create payment record and update order status
      const payment = await context.repositories.orderRepository.processPayment(
        Number(args.orderId),
        {
          amount,
          method: args.type,
        }
      );

      return payment;
    },

    createPaymentForTable: async (
      _: unknown,
      args: { type: string; tableId: string },
      context: GraphQLContext
    ) => {
      requireRole(context, [RoleEnum.STAFF, RoleEnum.MANAGER, RoleEnum.SUPERADMIN]);

      // Get all unpaid orders for the table
      const orders = await context.repositories.orderRepository.findUnpaidByTableId(Number(args.tableId));

      if (orders.length === 0) {
        throw new Error("No unpaid orders found for this table");
      }

      // Process payment for all orders
      const updatedOrders = await Promise.all(
        orders.map(order =>
          context.repositories.orderRepository.processPayment(order.id, {
            amount: order.getTotalAmount(),
            method: args.type,
          })
        )
      );

      return orders; // Return the original orders as they were before payment
    },
  },
};
</file>

<file path="backend/interfaces/graphql/context.ts">
import DataLoader from "dataloader";
import { RoleEnum } from "@prisma/client";
import { User } from "../../domain/entities/User";
import { MenuItem } from "../../domain/entities/MenuItem";
import { Table } from "../../domain/entities/Table";
import { Order } from "../../domain/entities/Order";
import { PrismaUserRepository } from "../../infrastructure/repositories/PrismaUserRepository";
import { PrismaMenuItemRepository } from "../../infrastructure/repositories/PrismaMenuItemRepository";
import { PrismaTableRepository } from "../../infrastructure/repositories/PrismaTableRepository";
import { PrismaOrderRepository } from "../../infrastructure/repositories/PrismaOrderRepository";
import { AuthenticateUser } from "../../application/useCases/UserAuthentication";
import jwt from "jsonwebtoken";

export interface GraphQLContext {
  user?: User;
  dataloaders: {
    userLoader: DataLoader<number, User | null>;
    menuItemLoader: DataLoader<number, MenuItem | null>;
    tableLoader: DataLoader<number, Table | null>;
    orderLoader: DataLoader<number, Order | null>;
    ordersByTableLoader: DataLoader<number, Order[]>;
  };
  repositories: {
    userRepository: PrismaUserRepository;
    menuItemRepository: PrismaMenuItemRepository;
    tableRepository: PrismaTableRepository;
    orderRepository: PrismaOrderRepository;
  };
  useCases: {
    authenticateUser: AuthenticateUser;
  };
}

// Type alias for Context used in resolvers
export type Context = GraphQLContext;

// Authentication utilities
export function signToken(user: { id: number; email: string; role: string }): string {
  return jwt.sign(
    { id: user.id, email: user.email, role: user.role },
    process.env.JWT_SECRET || "your-secret-key",
    { expiresIn: "24h" }
  );
}

export function requireRole(ctx: Context, allowedRoles: RoleEnum[]): void {
  if (!ctx.user) {
    throw new Error("No autorizado");
  }
  
  if (!allowedRoles.includes(ctx.user.role as RoleEnum)) {
    throw new Error("No tienes permisos para realizar esta acción");
  }
}

export async function createGraphQLContext(req: any): Promise<GraphQLContext> {
  // Handle different request types (Express vs GraphQL Yoga)
  let authHeader: string | null = null;
  
  if (req?.headers) {
    // Check if headers is a Headers-like object with .get() method
    if (typeof req.headers.get === 'function') {
      authHeader = req.headers.get('authorization');
    } else if (req.headers.authorization) {
      // Standard object headers
      authHeader = req.headers.authorization;
    }
  }
  
  // Initialize repositories
  const userRepository = new PrismaUserRepository();
  const menuItemRepository = new PrismaMenuItemRepository();
  const tableRepository = new PrismaTableRepository();
  const orderRepository = new PrismaOrderRepository();

  // Initialize use cases
  const authenticateUser = new AuthenticateUser(userRepository);

  // Create DataLoaders
  const userLoader = new DataLoader<number, User | null>(async (ids) => {
    const users = await Promise.all(
      ids.map((id) => userRepository.findById(id)),
    );
    return users;
  });

  const menuItemLoader = new DataLoader<number, MenuItem | null>(
    async (ids) => {
      const items = await Promise.all(
        ids.map((id) => menuItemRepository.findById(id)),
      );
      return items;
    },
  );

  const tableLoader = new DataLoader<number, Table | null>(async (ids) => {
    const tables = await Promise.all(
      ids.map((id) => tableRepository.findById(id)),
    );
    return tables;
  });

  const orderLoader = new DataLoader<number, Order | null>(async (ids) => {
    const orders = await Promise.all(
      ids.map((id) => orderRepository.findById(id)),
    );
    return orders;
  });

  const ordersByTableLoader = new DataLoader<number, Order[]>(
    async (tableIds) => {
      const ordersByTable = await Promise.all(
        tableIds.map((tableId) => orderRepository.findByTableId(tableId)),
      );
      return ordersByTable;
    },
  );

  // Extract user from JWT token
  let user: User | undefined;
  
  if (authHeader && authHeader.startsWith('Bearer ')) {
    const token = authHeader.replace('Bearer ', '');
    
    try {
      const decoded = jwt.verify(
        token,
        process.env.JWT_SECRET || "your-secret-key",
      ) as any;
      
      // Use the correct field name from the JWT payload
      const userId = decoded.id || decoded.userId;
      
      if (userId) {
        const loadedUser = await userLoader.load(userId);
        user = loadedUser || undefined;
      }
    } catch (error) {
      // Invalid token, user remains undefined
    }
  }

  return {
    user,
    dataloaders: {
      userLoader,
      menuItemLoader,
      tableLoader,
      orderLoader,
      ordersByTableLoader,
    },
    repositories: {
      userRepository,
      menuItemRepository,
      tableRepository,
      orderRepository,
    },
    useCases: {
      authenticateUser,
    },
  };
}
</file>

<file path="frontend-nextjs/src/app/menu/[qrCode]/page.tsx">
'use client';

import { useQuery, useMutation } from '@apollo/client';
import { useParams } from 'next/navigation';
import { useState } from 'react';
import { GET_TABLE_BY_QR_CODE, GET_MENU_ITEMS, CREATE_ORDER_BY_QR_CODE, GET_ORDERS_BY_QR_CODE } from '@/lib/queries';
import type { Order, OrderItem } from '@/types';
import { Button, Card, CardHeader, CardContent, Badge, getStatusBadgeVariant } from '@/components/ui';
import { GRID_LAYOUTS, SPACING, CONTAINER, FLEX, TEXT, cn } from '@/lib/styles';

interface MenuItem {
  id: string;
  name: string;
  price: number;
  sku: string;
  isAvailable: boolean;
}

interface CartItem {
  menuItemId: string;
  quantity: number;
  name: string;
  price: number;
}

export default function MenuQRPage() {
  const params = useParams();
  const qrCode = params.qrCode as string;
  
  const [cart, setCart] = useState<CartItem[]>([]);
  const [orderPlaced, setOrderPlaced] = useState(false);

  // Queries
  const { data: tableData, loading: tableLoading, error: tableError } = useQuery(GET_TABLE_BY_QR_CODE, {
    variables: { qrCode },
    skip: !qrCode,
  });

  const { data: menuData, loading: menuLoading } = useQuery(GET_MENU_ITEMS);
  
  const { data: ordersData, refetch: refetchOrders } = useQuery(GET_ORDERS_BY_QR_CODE, {
    variables: { qrCode },
    skip: !qrCode,
    pollInterval: 5000, // Poll every 5 seconds to get updates
  });

  // Mutation
  const [createOrderByQrCode, { loading: orderLoading }] = useMutation(CREATE_ORDER_BY_QR_CODE, {
    onCompleted: () => {
      setCart([]);
      setOrderPlaced(true);
      refetchOrders();
      setTimeout(() => setOrderPlaced(false), 3000);
    },
    onError: (error) => {
      console.error('Error creating order:', error);
    },
  });

  const addToCart = (item: MenuItem) => {
    setCart(prevCart => {
      const existingItem = prevCart.find(cartItem => cartItem.menuItemId === item.id);
      if (existingItem) {
        return prevCart.map(cartItem =>
          cartItem.menuItemId === item.id
            ? { ...cartItem, quantity: cartItem.quantity + 1 }
            : cartItem
        );
      }
      return [...prevCart, {
        menuItemId: item.id,
        quantity: 1,
        name: item.name,
        price: item.price,
      }];
    });
  };

  const removeFromCart = (menuItemId: string) => {
    setCart(prevCart => {
      const existingItem = prevCart.find(cartItem => cartItem.menuItemId === menuItemId);
      if (existingItem && existingItem.quantity > 1) {
        return prevCart.map(cartItem =>
          cartItem.menuItemId === menuItemId
            ? { ...cartItem, quantity: cartItem.quantity - 1 }
            : cartItem
        );
      }
      return prevCart.filter(cartItem => cartItem.menuItemId !== menuItemId);
    });
  };

  const getTotalPrice = () => {
    return cart.reduce((total, item) => total + (item.price * item.quantity), 0);
  };

  const formatPrice = (price: number) => {
    return new Intl.NumberFormat('es-CO', {
      style: 'currency',
      currency: 'COP',
      minimumFractionDigits: 0
    }).format(price);
  };

  const handlePlaceOrder = () => {
    if (cart.length === 0) return;
    
    const items = cart.map(item => ({
      menuItemId: item.menuItemId,
      quantity: item.quantity,
    }));

    createOrderByQrCode({
      variables: {
        qrCode,
        items,
      },
    });
  };

  if (tableLoading || menuLoading) {
    return (
      <div className={cn(FLEX.center, 'min-h-screen bg-gray-50')}>
        <div className="text-center">
          <div className="animate-spin rounded-full h-32 w-32 border-b-2 border-blue-600 mx-auto"></div>
          <p className={cn(TEXT.body, 'mt-4')}>Cargando menú...</p>
        </div>
      </div>
    );
  }

  if (tableError || !tableData?.getTableByQrCode) {
    return (
      <div className={cn(FLEX.center, 'min-h-screen bg-gray-50')}>
        <div className="text-center">
          <h1 className={cn(TEXT.heading2, 'text-red-600 mb-4')}>Mesa no encontrada</h1>
          <p className={TEXT.body}>El código QR escaneado no es válido.</p>
        </div>
      </div>
    );
  }

  const table = tableData.getTableByQrCode;
  const menuItems = menuData?.items || [];
  const orders = ordersData?.getOrdersByQrCode || [];

  return (
    <div className="min-h-screen bg-gray-50">
      {/* Header */}
      <div className="bg-white shadow-sm">
        <div className={cn(CONTAINER.maxWidth, CONTAINER.padding, 'py-4')}>
          <div className={FLEX.between}>
            <div>
              <h1 className={TEXT.heading2}>Menú Restaurante</h1>
              <p className={TEXT.body}>Mesa {table.number} - Capacidad: {table.capacity} personas</p>
            </div>
            <Badge variant="info" size="lg">
              Mesa #{table.number}
            </Badge>
          </div>
        </div>
      </div>

      <div className={cn(CONTAINER.maxWidth, CONTAINER.padding, 'py-8')}>
        <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
          {/* Menu Items */}
          <div className="lg:col-span-2">
            <h2 className={cn(TEXT.heading3, SPACING.section)}>Nuestro Menú</h2>
            <div className={GRID_LAYOUTS.responsive}>
              {menuItems.map((item: MenuItem) => (
                <Card key={item.id}>
                  <CardContent>
                    <div className={cn(FLEX.between, SPACING.header)}>
                      <div>
                        <h3 className={TEXT.heading4}>{item.name}</h3>
                        <p className={TEXT.small}>SKU: {item.sku}</p>
                      </div>
                      <span className="text-lg font-bold text-green-600">
                        {formatPrice(item.price)}
                      </span>
                    </div>
                    
                    {item.isAvailable ? (
                      <Button
                        variant="primary"
                        onClick={() => addToCart(item)}
                        className="w-full"
                      >
                        Agregar al pedido
                      </Button>
                    ) : (
                      <Button
                        variant="secondary"
                        disabled
                        className="w-full"
                      >
                        No disponible
                      </Button>
                    )}
                  </CardContent>
                </Card>
              ))}
            </div>
          </div>

          {/* Cart and Orders */}
          <div className="space-y-6">
            {/* Cart */}
            <Card>
              <CardHeader>
                <h3 className={TEXT.heading3}>Tu Pedido</h3>
              </CardHeader>
              <CardContent>
                {cart.length === 0 ? (
                  <p className={cn(TEXT.body, 'text-center py-4')}>No hay items en tu pedido</p>
                ) : (
                  <>
                    {cart.map((item) => (
                      <div key={item.menuItemId} className={cn(FLEX.between, 'py-2 border-b')}>
                        <div>
                          <p className="font-medium">{item.name}</p>
                          <p className={TEXT.small}>{formatPrice(item.price)} c/u</p>
                        </div>
                        <div className="flex items-center space-x-2">
                          <Button
                            variant="danger"
                            size="xs"
                            onClick={() => removeFromCart(item.menuItemId)}
                            className="w-8 h-8 rounded-full p-0"
                          >
                            -
                          </Button>
                          <span className="w-8 text-center">{item.quantity}</span>
                          <Button
                            variant="success"
                            size="xs"
                            onClick={() => addToCart({ id: item.menuItemId, name: item.name, price: item.price, sku: '', isAvailable: true })}
                            className="w-8 h-8 rounded-full p-0"
                          >
                            +
                          </Button>
                        </div>
                      </div>
                    ))}
                    
                    <div className="mt-4 pt-4 border-t">
                      <div className={cn(FLEX.between, SPACING.header)}>
                        <span className="text-lg font-semibold">Total:</span>
                        <span className="text-lg font-bold text-green-600">
                          {formatPrice(getTotalPrice())}
                        </span>
                      </div>
                      
                      <Button
                        variant="success"
                        onClick={handlePlaceOrder}
                        loading={orderLoading}
                        className="w-full"
                        size="lg"
                      >
                        Realizar Pedido
                      </Button>
                    </div>
                  </>
                )}
              </CardContent>
            </Card>

            {/* Order Success Message */}
            {orderPlaced && (
              <Card className="border-green-400 bg-green-50">
                <CardContent>
                  <p className="font-medium text-green-700">¡Pedido realizado con éxito!</p>
                  <p className={cn(TEXT.small, 'text-green-600')}>Tu pedido ha sido enviado a la cocina.</p>
                </CardContent>
              </Card>
            )}

            {/* Current Orders */}
            {orders.length > 0 && (
              <Card>
                <CardHeader>
                  <h3 className={TEXT.heading3}>Pedidos de la Mesa</h3>
                </CardHeader>
                <CardContent>
                  {orders.map((order: Order) => (
                    <div key={order.id} className="border-b pb-4 mb-4 last:border-b-0">
                      <div className={cn(FLEX.between, SPACING.content)}>
                        <span className={TEXT.heading4}>
                          Pedido #{order.id}
                        </span>
                        <Badge variant={getStatusBadgeVariant(order.status)}>
                          {order.status}
                        </Badge>
                      </div>
                      {order.orderItems?.map((item: OrderItem) => (
                        <div key={item.id} className={TEXT.small}>
                          {item.quantity}x {item.menuItem?.name} - {formatPrice(item.price)}
                        </div>
                      ))}
                    </div>
                  ))}
                </CardContent>
              </Card>
            )}
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="frontend-nextjs/src/app/page.tsx">
'use client';

import { useState, useEffect } from "react";
import ClientProvider, { apolloClient } from "./client-provider";
import Auth from "../components/Auth";
import Dashboard from "../components/Dashboard";

function AppContent() {
  const [token, setToken] = useState<string | null>(null);

  useEffect(() => {
    // Check if user is already logged in
    const savedToken = localStorage.getItem("token");
    if (savedToken) {
      setToken(savedToken);
    }
  }, []);

  const handleLogin = (newToken: string) => {
    setToken(newToken);
  };

  const handleLogout = () => {
    localStorage.removeItem("token");
    setToken(null);
    // Clear Apollo cache using the exported client
    apolloClient.clearStore();
  };

  return (
    <>
      {token ? (
        <Dashboard onLogout={handleLogout} />
      ) : (
        <Auth onLogin={handleLogin} />
      )}
    </>
  );
}

export default function Home() {
  return (
    <ClientProvider>
      <AppContent />
    </ClientProvider>
  );
}
</file>

<file path="frontend-nextjs/src/components/ui/Badge.tsx">
import React from 'react';

export type BadgeVariant = 'default' | 'success' | 'warning' | 'danger' | 'info' | 'secondary';
export type BadgeSize = 'sm' | 'md' | 'lg';

interface BadgeProps {
  children: React.ReactNode;
  variant?: BadgeVariant;
  size?: BadgeSize;
  className?: string;
}

const getVariantClasses = (variant: BadgeVariant): string => {
  const variants = {
    default: 'bg-gray-200 text-gray-900',
    success: 'bg-green-200 text-green-900',
    warning: 'bg-yellow-200 text-yellow-900',
    danger: 'bg-red-200 text-red-900',
    info: 'bg-blue-200 text-blue-900',
    secondary: 'bg-purple-200 text-purple-900',
  };
  return variants[variant];
};

const getSizeClasses = (size: BadgeSize): string => {
  const sizes = {
    sm: 'px-1.5 py-0.5 text-xs',
    md: 'px-2 py-1 text-xs',
    lg: 'px-3 py-1 text-sm',
  };
  return sizes[size];
};

export const Badge: React.FC<BadgeProps> = ({
  children,
  variant = 'default',
  size = 'md',
  className = '',
}) => {
  const baseClasses = 'inline-flex font-semibold rounded-full';
  const variantClasses = getVariantClasses(variant);
  const sizeClasses = getSizeClasses(size);

  const combinedClassName = `${baseClasses} ${variantClasses} ${sizeClasses} ${className}`.trim();

  return (
    <span className={combinedClassName}>
      {children}
    </span>
  );
};

// Helper function to map common status strings to badge variants
export const getStatusBadgeVariant = (status: string): BadgeVariant => {
  const statusLower = status.toLowerCase();
  
  if (statusLower.includes('success') || statusLower.includes('delivered') || statusLower.includes('paid') || statusLower.includes('available')) {
    return 'success';
  }
  if (statusLower.includes('warning') || statusLower.includes('pending') || statusLower.includes('preparing')) {
    return 'warning';
  }
  if (statusLower.includes('error') || statusLower.includes('failed') || statusLower.includes('cancelled') || statusLower.includes('unavailable')) {
    return 'danger';
  }
  if (statusLower.includes('info') || statusLower.includes('ready')) {
    return 'info';
  }
  
  return 'default';
};
</file>

<file path="frontend-nextjs/src/components/ui/Button.tsx">
import React from 'react';

export type ButtonVariant = 'primary' | 'secondary' | 'success' | 'danger' | 'warning' | 'info';
export type ButtonSize = 'xs' | 'sm' | 'md' | 'lg';

interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: ButtonVariant;
  size?: ButtonSize;
  loading?: boolean;
  children: React.ReactNode;
}

const getVariantClasses = (variant: ButtonVariant): string => {
  const variants = {
    primary: 'bg-indigo-600 hover:bg-indigo-700 text-white border border-indigo-600 hover:border-indigo-700',
    secondary: 'bg-gray-700 hover:bg-gray-800 text-white border border-gray-700 hover:border-gray-800',
    success: 'bg-green-600 hover:bg-green-700 text-white border border-green-600 hover:border-green-700',
    danger: 'bg-red-600 hover:bg-red-700 text-white border border-red-600 hover:border-red-700',
    warning: 'bg-yellow-500 hover:bg-yellow-600 text-white border border-yellow-500 hover:border-yellow-600',
    info: 'bg-blue-600 hover:bg-blue-700 text-white border border-blue-600 hover:border-blue-700',
  };
  return variants[variant];
};

const getSizeClasses = (size: ButtonSize): string => {
  const sizes = {
    xs: 'py-1 px-2 text-xs',
    sm: 'py-1 px-3 text-sm',
    md: 'py-2 px-4 text-sm',
    lg: 'py-2 px-6 text-base',
  };
  return sizes[size];
};

export const Button: React.FC<ButtonProps> = ({
  variant = 'primary',
  size = 'md',
  loading = false,
  disabled,
  className = '',
  children,
  ...props
}) => {
  const baseClasses = 'font-medium rounded focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-colors duration-200';
  const variantClasses = getVariantClasses(variant);
  const sizeClasses = getSizeClasses(size);
  const disabledClasses = (disabled || loading) ? 'opacity-50 cursor-not-allowed' : '';

  const combinedClassName = `${baseClasses} ${variantClasses} ${sizeClasses} ${disabledClasses} ${className}`.trim();

  return (
    <button
      className={combinedClassName}
      disabled={disabled || loading}
      {...props}
    >
      {loading ? (
        <span className="flex items-center">
          <svg className="animate-spin -ml-1 mr-3 h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
            <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
            <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
          </svg>
          Cargando...
        </span>
      ) : (
        children
      )}
    </button>
  );
};
</file>

<file path="frontend-nextjs/src/components/ui/Input.tsx">
import React from 'react';

export type InputType = 'text' | 'email' | 'password' | 'number' | 'datetime-local' | 'select';

interface BaseInputProps {
  label: string;
  id?: string;
  error?: string;
  required?: boolean;
  className?: string;
}

interface TextInputProps extends BaseInputProps {
  type: 'text' | 'email' | 'password' | 'number' | 'datetime-local';
  value: string | number;
  onChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
  placeholder?: string;
  min?: string | number;
  max?: string | number;
  step?: string | number;
}

interface SelectInputProps extends BaseInputProps {
  type: 'select';
  value: string;
  onChange: (e: React.ChangeEvent<HTMLSelectElement>) => void;
  options: Array<{ value: string; label: string }>;
}

type InputProps = TextInputProps | SelectInputProps;

export const Input: React.FC<InputProps> = (props) => {
  const { label, id, error, required, className = '' } = props;
  const inputId = id || label.toLowerCase().replace(/\s+/g, '-');

  const baseInputClasses = `mt-1 block w-full px-3 py-2 bg-white text-gray-900 placeholder-gray-500 border border-gray-300 rounded-md shadow-sm focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm ${
    error ? 'border-red-300 focus:border-red-500 focus:ring-red-500' : ''
  }`;

  return (
    <div className={className}>
      <label 
        htmlFor={inputId} 
        className={`block text-sm font-medium ${error ? 'text-red-700' : 'text-gray-700'}`}
      >
        {label}
        {required && <span className="text-red-500 ml-1">*</span>}
      </label>
      
      {props.type === 'select' ? (
        <select
          id={inputId}
          value={props.value}
          onChange={props.onChange}
          required={required}
          className={baseInputClasses}
        >
          {props.options.map((option) => (
            <option key={option.value} value={option.value}>
              {option.label}
            </option>
          ))}
        </select>
      ) : (
        <input
          id={inputId}
          type={props.type}
          value={props.value}
          onChange={props.onChange}
          placeholder={props.placeholder}
          required={required}
          min={props.min}
          max={props.max}
          step={props.step}
          className={baseInputClasses}
        />
      )}
      
      {error && (
        <p className="mt-1 text-sm text-red-600">{error}</p>
      )}
    </div>
  );
};
</file>

<file path="frontend-nextjs/src/components/Auth.tsx">
'use client';

import React, { useState } from 'react';
import { useMutation } from '@apollo/client';
import { LOGIN_MUTATION, SIGNUP_MUTATION } from '../lib/queries';
import type { AuthPayload } from '../types';
import { RoleEnum } from '../types';
import { Button, Input, Card, CardHeader, CardContent } from './ui';
import { CONTAINER, FLEX, TEXT, SPACING, cn } from '../lib/styles';

interface AuthProps {
  onLogin: (token: string) => void;
}

const Auth: React.FC<AuthProps> = ({ onLogin }) => {
  const [isLogin, setIsLogin] = useState(true);
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [name, setName] = useState('');
  const [role, setRole] = useState<RoleEnum>(RoleEnum.STAFF);

  const [login, { loading: loginLoading, error: loginError }] = useMutation<{ login: AuthPayload }>(LOGIN_MUTATION);
  const [signup, { loading: signupLoading, error: signupError }] = useMutation<{ signup: AuthPayload }>(SIGNUP_MUTATION);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      if (isLogin) {
        const result = await login({ variables: { email, password } });
        if (result.data?.login.token) {
          localStorage.setItem('token', result.data.login.token);
          onLogin(result.data.login.token);
        }
      } else {
        const result = await signup({ variables: { email, password, name, role } });
        if (result.data?.signup.token) {
          localStorage.setItem('token', result.data.signup.token);
          onLogin(result.data.signup.token);
        }
      }
    } catch (error) {
      console.error('Error:', error);
    }
  };

  const quickLogin = async (userEmail: string, userPassword: string) => {
    try {
      const result = await login({ variables: { email: userEmail, password: userPassword } });
      if (result.data?.login.token) {
        localStorage.setItem('token', result.data.login.token);
        onLogin(result.data.login.token);
      }
    } catch (error) {
      console.error('Error:', error);
    }
  };

  const isLoading = loginLoading || signupLoading;
  const error = loginError || signupError;

  return (
    <div className="min-h-screen bg-gray-50 flex flex-col justify-center py-12 sm:px-6 lg:px-8">
      <div className="sm:mx-auto sm:w-full sm:max-w-md">
        <h2 className={cn(TEXT.heading1, 'mt-6 text-center')}>
          {isLogin ? 'Iniciar Sesión' : 'Registrarse'}
        </h2>
      </div>

      <div className="mt-8 sm:mx-auto sm:w-full sm:max-w-md">
        <Card>
          <CardContent>
            {/* Quick login buttons */}
            <div className={SPACING.section}>
              <h4 className={cn(TEXT.heading3, SPACING.content, 'text-center')}>Login rápido:</h4>
              <div className={cn(FLEX.wrap, 'justify-center')}>
                <Button 
                  variant="info"
                  size="sm"
                  onClick={() => quickLogin('admin@food360.local', '123456')}
                  aria-label="Login rápido como administrador"
                >
                  Admin
                </Button>
                <Button 
                  variant="info"
                  size="sm"
                  onClick={() => quickLogin('manager@food360.local', 'manager')}
                  aria-label="Login rápido como manager"
                  className="bg-cyan-600 hover:bg-cyan-700"
                >
                  Manager
                </Button>
                <Button 
                  variant="success"
                  size="sm"
                  onClick={() => quickLogin('staff@food360.local', 'staff')}
                  aria-label="Login rápido como staff"
                >
                  Staff
                </Button>
              </div>
            </div>

            <hr className={SPACING.section} />

            <form onSubmit={handleSubmit} className="space-y-6">
              <Input
                type="email"
                label="Email"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                required
              />

              <Input
                type="password"
                label="Password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                required
              />

              {!isLogin && (
                <>
                  <Input
                    type="text"
                    label="Nombre"
                    value={name}
                    onChange={(e) => setName(e.target.value)}
                    required
                  />
                  
                  <Input
                    type="select"
                    label="Rol"
                    value={role}
                    onChange={(e) => setRole(e.target.value as RoleEnum)}
                    options={[
                      { value: RoleEnum.STAFF, label: 'Staff' },
                      { value: RoleEnum.MANAGER, label: 'Manager' },
                      { value: RoleEnum.SUPERADMIN, label: 'Super Admin' }
                    ]}
                  />
                </>
              )}

              <Button
                type="submit"
                variant="primary"
                disabled={isLoading}
                loading={isLoading}
                className="w-full"
              >
                {isLogin ? 'Iniciar Sesión' : 'Registrarse'}
              </Button>
            </form>

            {error && (
              <div className="mt-4 p-3 bg-red-50 border border-red-200 rounded-md">
                <div className={TEXT.error}>
                  <strong>Error:</strong> {error.message}
                </div>
              </div>
            )}

            <div className="mt-6 text-center">
              <span className={TEXT.small}>
                {isLogin ? '¿No tienes cuenta?' : '¿Ya tienes cuenta?'}
              </span>
              <button 
                type="button"
                onClick={() => setIsLogin(!isLogin)}
                className="ml-2 text-sm text-indigo-600 hover:text-indigo-500 font-medium"
              >
                {isLogin ? 'Registrarse' : 'Iniciar Sesión'}
              </button>
            </div>
          </CardContent>
        </Card>
      </div>
    </div>
  );
};

export default Auth;
</file>

<file path="frontend-nextjs/src/types.ts">
export enum RoleEnum {
  SUPERADMIN = 'SUPERADMIN',
  MANAGER = 'MANAGER',
  STAFF = 'STAFF',
}

export interface MenuItem {
  id: string;
  sku: string;
  name: string;
  price: number;
  imageUrl?: string;
  isAvailable: boolean;
  createdAt: string;
}

export interface Table {
  id: string;
  number: number;
  capacity: number;
  qrCode?: string;
  orders?: Order[];
}

export interface OrderItem {
  id: string;
  orderId: number;
  menuItemId: number;
  quantity: number;
  price: number;
  menuItem?: MenuItem;
}

export interface Order {
  id: string;
  status: string;
  tableId: number;
  userId: number;
  createdAt: string;
  orderItems?: OrderItem[];
  table?: Table;
  user?: User;
}

export interface Payment {
  id: string;
  orderId: number;
  amount: number;
  method: string;
  paidAt: string;
  order?: Order;
}

export interface User {
  id: string;
  email: string;
  role: RoleEnum;
  createdAt: string;
  orders?: Order[];
}

export interface AuthPayload {
  token: string;
  user: User;
}
</file>

<file path="backend/infrastructure/repositories/PrismaMenuItemRepository.ts">
import {
  IMenuItemRepository,
  MenuItemFilter,
  MenuItemSort,
} from "../../application/interfaces/IMenuItemRepository";
import { MenuItem } from "../../domain/entities/MenuItem";
import {
  Connection,
  Cursor,
  Edge,
  PaginationInfo,
} from "../../domain/valueObjects/Pagination";
import prisma from "../prisma/client";

export class PrismaMenuItemRepository implements IMenuItemRepository {
  async findById(id: number): Promise<MenuItem | null> {
    const menuItem = await prisma.menuItem.findUnique({
      where: { id },
    });

    if (!menuItem) return null;

    return new MenuItem(
      menuItem.id,
      menuItem.sku,
      menuItem.name,
      Number(menuItem.price),
      menuItem.imageUrl || undefined,
      menuItem.isAvailable,
      menuItem.createdAt,
    );
  }

  async findBySku(sku: string): Promise<MenuItem | null> {
    const menuItem = await prisma.menuItem.findUnique({
      where: { sku },
    });

    if (!menuItem) return null;

    return new MenuItem(
      menuItem.id,
      menuItem.sku,
      menuItem.name,
      Number(menuItem.price),
      menuItem.imageUrl || undefined,
      menuItem.isAvailable,
      menuItem.createdAt,
    );
  }

  async findMany(
    filter?: MenuItemFilter,
    sort?: MenuItemSort,
    first: number = 10,
    after?: Cursor,
  ): Promise<Connection<MenuItem>> {
    const where: any = {};

    if (filter) {
      if (filter.name) {
        where.name = { contains: filter.name, mode: "insensitive" };
      }
      if (filter.priceMin !== undefined || filter.priceMax !== undefined) {
        where.price = {};
        if (filter.priceMin !== undefined) {
          where.price.gte = filter.priceMin;
        }
        if (filter.priceMax !== undefined) {
          where.price.lte = filter.priceMax;
        }
      }
      if (filter.isAvailable !== undefined) {
        where.isAvailable = filter.isAvailable;
      }
    }

    // Handle cursor-based pagination
    if (after && !after.isEmpty()) {
      where.id = { gt: after.toId() };
    }

    const orderBy: any = {};
    if (sort) {
      orderBy[sort.field] = sort.order;
    } else {
      orderBy.id = "asc";
    }

    const items = await prisma.menuItem.findMany({
      where,
      orderBy,
      take: first + 1, // Get one extra to check if there's a next page
    });

    const hasNextPage = items.length > first;
    const menuItems = hasNextPage ? items.slice(0, -1) : items;

    const edges: Edge<MenuItem>[] = menuItems.map((item) => ({
      node: new MenuItem(
        item.id,
        item.sku,
        item.name,
        Number(item.price),
        item.imageUrl || undefined,
        item.isAvailable,
        item.createdAt,
      ),
      cursor: Cursor.fromId(item.id),
    }));

    const pageInfo = new PaginationInfo(
      hasNextPage,
      !!after && !after.isEmpty(),
      edges.length > 0 ? edges[0].cursor : undefined,
      edges.length > 0 ? edges[edges.length - 1].cursor : undefined,
    );

    return new Connection(edges, pageInfo);
  }

  async create(menuItemData: {
    sku: string;
    name: string;
    price: number;
    imageUrl?: string;
    isAvailable?: boolean;
  }): Promise<MenuItem> {
    const menuItem = await prisma.menuItem.create({
      data: {
        sku: menuItemData.sku,
        name: menuItemData.name,
        price: menuItemData.price,
        imageUrl: menuItemData.imageUrl,
        isAvailable: menuItemData.isAvailable ?? true,
      },
    });

    return new MenuItem(
      menuItem.id,
      menuItem.sku,
      menuItem.name,
      Number(menuItem.price),
      menuItem.imageUrl || undefined,
      menuItem.isAvailable,
      menuItem.createdAt,
    );
  }

  async update(id: number, menuItemData: Partial<MenuItem>): Promise<MenuItem> {
    const updateData: any = {};
    if (menuItemData.name !== undefined) updateData.name = menuItemData.name;
    if (menuItemData.price !== undefined) updateData.price = menuItemData.price;
    if (menuItemData.imageUrl !== undefined) updateData.imageUrl = menuItemData.imageUrl;
    if (menuItemData.isAvailable !== undefined)
      updateData.isAvailable = menuItemData.isAvailable;

    const menuItem = await prisma.menuItem.update({
      where: { id },
      data: updateData,
    });

    return new MenuItem(
      menuItem.id,
      menuItem.sku,
      menuItem.name,
      Number(menuItem.price),
      menuItem.imageUrl || undefined,
      menuItem.isAvailable,
      menuItem.createdAt,
    );
  }

  async delete(id: number): Promise<void> {
    await prisma.menuItem.delete({
      where: { id },
    });
  }

  async count(filter?: MenuItemFilter): Promise<number> {
    const where: any = {};

    if (filter) {
      if (filter.name) {
        where.name = { contains: filter.name, mode: "insensitive" };
      }
      if (filter.priceMin !== undefined || filter.priceMax !== undefined) {
        where.price = {};
        if (filter.priceMin !== undefined) {
          where.price.gte = filter.priceMin;
        }
        if (filter.priceMax !== undefined) {
          where.price.lte = filter.priceMax;
        }
      }
      if (filter.isAvailable !== undefined) {
        where.isAvailable = filter.isAvailable;
      }
    }

    return await prisma.menuItem.count({ where });
  }

  async findManyWithPagination(
    filter?: MenuItemFilter,
    sort?: MenuItemSort,
    limit: number = 12,
    offset: number = 0,
  ): Promise<MenuItem[]> {
    const where: any = {};

    if (filter) {
      if (filter.name) {
        where.name = { contains: filter.name, mode: "insensitive" };
      }
      if (filter.priceMin !== undefined || filter.priceMax !== undefined) {
        where.price = {};
        if (filter.priceMin !== undefined) {
          where.price.gte = filter.priceMin;
        }
        if (filter.priceMax !== undefined) {
          where.price.lte = filter.priceMax;
        }
      }
      if (filter.isAvailable !== undefined) {
        where.isAvailable = filter.isAvailable;
      }
    }

    const orderBy: any = {};
    if (sort) {
      orderBy[sort.field] = sort.order;
    } else {
      orderBy.name = "asc";
    }

    const items = await prisma.menuItem.findMany({
      where,
      orderBy,
      take: limit,
      skip: offset,
    });

    return items.map((item) => new MenuItem(
      item.id,
      item.sku,
      item.name,
      Number(item.price),
      item.imageUrl || undefined,
      item.isAvailable,
      item.createdAt,
    ));
  }
}
</file>

<file path="backend/infrastructure/repositories/PrismaOrderRepository.ts">
import {
  IOrderRepository,
  OrderFilter,
  OrderSort,
} from "../../application/interfaces/IOrderRepository";
import { Order, OrderItem, OrderStatus } from "../../domain/entities/Order";
import {
  Connection,
  Cursor,
  Edge,
  PaginationInfo,
} from "../../domain/valueObjects/Pagination";
import prisma from "../prisma/client";

export class PrismaOrderRepository implements IOrderRepository {
  async findById(id: number): Promise<Order | null> {
    const order = await prisma.order.findUnique({
      where: { id },
      include: {
        orderItems: true,
      },
    });

    if (!order) return null;

    const orderItems = order.orderItems.map(
      (item) =>
        new OrderItem(
          item.id,
          item.orderId,
          item.menuItemId,
          item.quantity,
          Number(item.price),
        ),
    );

    return new Order(
      order.id,
      order.status as OrderStatus,
      order.tableId,
      order.userId,
      order.createdAt,
      orderItems,
    );
  }

  async findByTableId(tableId: number): Promise<Order[]> {
    const orders = await prisma.order.findMany({
      where: { tableId },
      include: {
        orderItems: true,
      },
    });

    return this.mapOrdersFromPrisma(orders);
  }

  async findByQrCode(qrCode: string): Promise<Order[]> {
    const table = await prisma.table.findUnique({
      where: { qrCode },
    });

    if (!table) return [];

    return this.findByTableId(table.id);
  }

  async findMany(
    filter?: OrderFilter,
    sort?: OrderSort,
    first: number = 10,
    after?: Cursor,
  ): Promise<Connection<Order>> {
    const where: any = {};

    if (filter) {
      if (filter.status) {
        where.status = filter.status;
      }
      if (filter.tableId !== undefined) {
        where.tableId = filter.tableId;
      }
      if (filter.userId !== undefined) {
        where.userId = filter.userId;
      }
      if (filter.createdAfter || filter.createdBefore) {
        where.createdAt = {};
        if (filter.createdAfter) {
          where.createdAt.gte = filter.createdAfter;
        }
        if (filter.createdBefore) {
          where.createdAt.lte = filter.createdBefore;
        }
      }
    }

    // Handle cursor-based pagination
    if (after && !after.isEmpty()) {
      where.id = { gt: after.toId() };
    }

    const orderBy: any = {};
    if (sort) {
      orderBy[sort.field] = sort.order;
    } else {
      orderBy.id = "asc";
    }

    const orders = await prisma.order.findMany({
      where,
      orderBy,
      take: first + 1,
      include: {
        orderItems: true,
      },
    });

    const hasNextPage = orders.length > first;
    const orderList = hasNextPage ? orders.slice(0, -1) : orders;

    const edges: Edge<Order>[] = orderList.map((order) => ({
      node: this.mapOrderFromPrisma(order),
      cursor: Cursor.fromId(order.id),
    }));

    const pageInfo = new PaginationInfo(
      hasNextPage,
      !!after && !after.isEmpty(),
      edges.length > 0 ? edges[0].cursor : undefined,
      edges.length > 0 ? edges[edges.length - 1].cursor : undefined,
    );

    return new Connection(edges, pageInfo);
  }

  async create(orderData: {
    status: OrderStatus;
    tableId: number;
    userId: number;
    items?: { menuItemId: number; quantity: number }[];
  }): Promise<Order> {
    const order = await prisma.order.create({
      data: {
        status: orderData.status,
        tableId: orderData.tableId,
        userId: orderData.userId,
      },
      include: {
        orderItems: true,
      },
    });

    // Add order items if provided
    if (orderData.items && orderData.items.length > 0) {
      for (const item of orderData.items) {
        // Get menu item to get price
        const menuItem = await prisma.menuItem.findUnique({
          where: { id: item.menuItemId },
        });

        if (!menuItem) {
          throw new Error(`Menu item with ID ${item.menuItemId} not found`);
        }

        await this.addOrderItem(order.id, {
          menuItemId: item.menuItemId,
          quantity: item.quantity,
          price: Number(menuItem.price),
        });
      }

      // Fetch the order again with order items
      const updatedOrder = await prisma.order.findUnique({
        where: { id: order.id },
        include: {
          orderItems: true,
        },
      });

      return this.mapOrderFromPrisma(updatedOrder);
    }

    return this.mapOrderFromPrisma(order);
  }

  async update(id: number, orderData: Partial<Order>): Promise<Order> {
    const updateData: any = {};
    if (orderData.status !== undefined) updateData.status = orderData.status;

    const order = await prisma.order.update({
      where: { id },
      data: updateData,
      include: {
        orderItems: true,
      },
    });

    return this.mapOrderFromPrisma(order);
  }

  async delete(id: number): Promise<void> {
    await prisma.order.delete({
      where: { id },
    });
  }

  async addOrderItem(
    orderId: number,
    orderItemData: {
      menuItemId: number;
      quantity: number;
      price: number;
    },
  ): Promise<OrderItem> {
    const orderItem = await prisma.orderItem.create({
      data: {
        orderId,
        menuItemId: orderItemData.menuItemId,
        quantity: orderItemData.quantity,
        price: orderItemData.price,
      },
    });

    return new OrderItem(
      orderItem.id,
      orderItem.orderId,
      orderItem.menuItemId,
      orderItem.quantity,
      Number(orderItem.price),
    );
  }

  async updateOrderStatus(id: number, status: OrderStatus): Promise<Order> {
    const order = await prisma.order.update({
      where: { id },
      data: { status },
      include: {
        orderItems: true,
      },
    });

    return this.mapOrderFromPrisma(order);
  }

  async updateStatus(id: number, status: OrderStatus): Promise<Order> {
    return this.updateOrderStatus(id, status);
  }

  async processPayment(
    orderId: number,
    paymentData: {
      amount: number;
      method: string;
    }
  ): Promise<any> {
    // Create payment record and update order status to PAID
    const payment = await prisma.payment.create({
      data: {
        orderId,
        amount: paymentData.amount,
        method: paymentData.method,
      },
    });

    // Update order status to PAID
    await this.updateOrderStatus(orderId, OrderStatus.PAID);

    return payment;
  }

  async findUnpaidByTableId(tableId: number): Promise<Order[]> {
    const orders = await prisma.order.findMany({
      where: {
        tableId,
        status: { not: OrderStatus.PAID },
      },
      include: {
        orderItems: true,
      },
    });

    return this.mapOrdersFromPrisma(orders);
  }

  async findManyWithPagination(
    filter?: OrderFilter,
    sort?: OrderSort,
    limit: number = 12,
    offset: number = 0,
  ): Promise<Order[]> {
    const where: any = {};

    if (filter) {
      if (filter.status) {
        where.status = filter.status;
      }
      if (filter.tableId !== undefined) {
        where.tableId = filter.tableId;
      }
      if (filter.userId !== undefined) {
        where.userId = filter.userId;
      }
      if (filter.createdAfter || filter.createdBefore) {
        where.createdAt = {};
        if (filter.createdAfter) {
          where.createdAt.gte = filter.createdAfter;
        }
        if (filter.createdBefore) {
          where.createdAt.lte = filter.createdBefore;
        }
      }
    }

    const orderBy: any = {};
    if (sort) {
      orderBy[sort.field] = sort.order;
    } else {
      orderBy.createdAt = "desc";
    }

    const orders = await prisma.order.findMany({
      where,
      orderBy,
      take: limit,
      skip: offset,
      include: {
        orderItems: true,
      },
    });

    return this.mapOrdersFromPrisma(orders);
  }

  async count(filter?: OrderFilter): Promise<number> {
    const where: any = {};

    if (filter) {
      if (filter.status) {
        where.status = filter.status;
      }
      if (filter.tableId !== undefined) {
        where.tableId = filter.tableId;
      }
      if (filter.userId !== undefined) {
        where.userId = filter.userId;
      }
      if (filter.createdAfter || filter.createdBefore) {
        where.createdAt = {};
        if (filter.createdAfter) {
          where.createdAt.gte = filter.createdAfter;
        }
        if (filter.createdBefore) {
          where.createdAt.lte = filter.createdBefore;
        }
      }
    }

    return await prisma.order.count({ where });
  }

  private mapOrderFromPrisma(order: any): Order {
    const orderItems = order.orderItems.map(
      (item: any) =>
        new OrderItem(
          item.id,
          item.orderId,
          item.menuItemId,
          item.quantity,
          Number(item.price),
        ),
    );

    // Asegurar que createdAt es una fecha válida
    let createdAt = new Date();
    if (order.createdAt) {
      if (order.createdAt instanceof Date) {
        createdAt = order.createdAt;
      } else {
        createdAt = new Date(order.createdAt);
      }

      // Verificar que la fecha es válida
      if (isNaN(createdAt.getTime())) {
        console.warn(
          `Invalid createdAt date for order ${order.id}: ${order.createdAt}`,
        );
        createdAt = new Date(); // Fallback a la fecha actual
      }
    }

    return new Order(
      order.id,
      order.status as OrderStatus,
      order.tableId,
      order.userId,
      createdAt,
      orderItems,
    );
  }

  private mapOrdersFromPrisma(orders: any[]): Order[] {
    return orders.map((order) => this.mapOrderFromPrisma(order));
  }
}
</file>

<file path="backend/interfaces/graphql/resolvers/tableResolvers.ts">
import { GraphQLContext } from "../context";
import { TableManagement } from "../../../application/useCases/TableManagement";
import { RoleEnum } from "@prisma/client";
import { requireRole } from "../utils/auth";

export const tableResolvers = {
  Query: {
    tables: async (
      _: unknown,
      args: {
        filter?: {
          number?: number;
          capacityMin?: number;
          capacityMax?: number;
          hasQrCode?: boolean;
        };
        sort?: {
          field: "id" | "number" | "capacity" | "orderCount";
          order: "asc" | "desc";
        };
        limit?: number;
        offset?: number;
      },
      context: GraphQLContext
    ) => {
      requireRole(context, [RoleEnum.STAFF, RoleEnum.MANAGER, RoleEnum.SUPERADMIN]);
      
      const tableManagement = new TableManagement(context.repositories.tableRepository);
      return tableManagement.listTables(args.filter, args.sort, args.limit, args.offset);
    },

    getTableById: async (
      _: unknown,
      args: { id: number },
      context: GraphQLContext
    ) => {
      requireRole(context, [RoleEnum.STAFF, RoleEnum.MANAGER, RoleEnum.SUPERADMIN]);
      return context.dataloaders.tableLoader.load(args.id);
    },

    getTableByQrCode: async (
      _: unknown,
      args: { qrCode: string },
      context: GraphQLContext
    ) => {
      // Public access - customers can access via QR code
      return context.repositories.tableRepository.findByQrCode(args.qrCode);
    },

    tablesCount: async (
      _: unknown,
      args: {
        filter?: {
          number?: number;
          capacityMin?: number;
          capacityMax?: number;
          hasQrCode?: boolean;
        };
      },
      context: GraphQLContext
    ) => {
      requireRole(context, [RoleEnum.STAFF, RoleEnum.MANAGER, RoleEnum.SUPERADMIN]);
      return context.repositories.tableRepository.count(args.filter);
    },
  },

  Mutation: {
    addTable: async (
      _: unknown,
      __: unknown,
      context: GraphQLContext
    ) => {
      requireRole(context, [RoleEnum.MANAGER, RoleEnum.STAFF, RoleEnum.SUPERADMIN]);
      
      const tableManagement = new TableManagement(context.repositories.tableRepository);
      return tableManagement.addTable();
    },

    removeTable: async (
      _: unknown,
      __: unknown,
      context: GraphQLContext
    ) => {
      requireRole(context, [RoleEnum.MANAGER, RoleEnum.STAFF, RoleEnum.SUPERADMIN]);
      
      const tableManagement = new TableManagement(context.repositories.tableRepository);
      return tableManagement.removeTable();
    },

    generateQrCodeForTable: async (
      _: unknown,
      args: { tableId: string },
      context: GraphQLContext
    ) => {
      requireRole(context, [RoleEnum.MANAGER, RoleEnum.SUPERADMIN]);
      
      const tableManagement = new TableManagement(context.repositories.tableRepository);
      return tableManagement.generateQrCode(Number(args.tableId));
    },
  },

  Table: {
    orders: async (parent: any, _: unknown, context: GraphQLContext) => {
      return context.repositories.orderRepository.findByTableId(parent.id);
    },
  },
};
</file>

<file path="backend/interfaces/graphql/resolvers/userResolvers.ts">
import { GraphQLContext } from "../context";
import { AuthenticateUser, CreateUser } from "../../../application/useCases/UserAuthentication";
import { sign } from "jsonwebtoken";
import { RoleEnum } from "../../../domain/entities/User";

const JWT_SECRET = process.env.JWT_SECRET || "your-secret-key";

function signToken(user: { id: number; role: RoleEnum }): string {
  return sign({ id: user.id, role: user.role }, JWT_SECRET, { expiresIn: "24h" });
}

export const userResolvers = {
  Query: {
    me: async (_: unknown, __: unknown, context: GraphQLContext) => {
      if (!context.user) {
        throw new Error("No autorizado");
      }

      // Get full user from database
      const fullUser = await context.repositories.userRepository.findById(context.user.id);
      if (!fullUser) {
        throw new Error("Usuario no encontrado");
      }

      return fullUser;
    },
  },

  Mutation: {
    signup: async (
      _: unknown,
      args: {
        email: string;
        password: string;
        name?: string;
        role?: RoleEnum;
      },
      context: GraphQLContext
    ) => {
      const { email, password, role = RoleEnum.STAFF } = args;
      
      const createUser = new CreateUser(context.repositories.userRepository);
      const user = await createUser.execute({
        email,
        password,
        role,
      });

      return {
        token: signToken({ id: user.id, role: user.role }),
        user,
      };
    },

    login: async (
      _: unknown,
      args: { email: string; password: string },
      context: GraphQLContext
    ) => {
      const authenticateUser = new AuthenticateUser(context.repositories.userRepository);
      const user = await authenticateUser.execute(args);

      return {
        token: signToken({ id: user.id, role: user.role }),
        user,
      };
    },
  },
};
</file>

<file path="frontend-nextjs/src/components/dashboard/Pagination.tsx">
import React from 'react';
import { Button } from '../ui';
import { FLEX, SPACING, TEXT, cn } from '../../lib/styles';

interface PaginationProps {
  currentPage: number;
  setPage: (page: number) => void;
  hasMore: boolean;
}

export const Pagination: React.FC<PaginationProps> = ({ currentPage, setPage, hasMore }) => (
  <div className="flex items-center justify-center space-x-4 py-6">
    <div className="flex items-center space-x-2">
      <Button
        variant="secondary"
        onClick={() => setPage(Math.max(0, currentPage - 1))}
        disabled={currentPage === 0}
        className={cn(
          "flex items-center space-x-2 transition-all duration-200",
          currentPage === 0 
            ? "opacity-50 cursor-not-allowed" 
            : "hover:scale-105 hover:shadow-md"
        )}
      >
        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" />
        </svg>
        <span>Anterior</span>
      </Button>
      
      <div className="flex items-center space-x-4 px-6 py-2 bg-gray-50 rounded-lg border">
        <div className="flex items-center space-x-2">
          <svg className="w-4 h-4 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-5.414-5.414A1 1 0 0012.586 3H7a2 2 0 00-2 2v14a2 2 0 002 2z" />
          </svg>
          <span className="text-sm font-medium text-gray-700">
            Página <span className="font-bold text-indigo-600">{currentPage + 1}</span>
          </span>
        </div>
        
        {hasMore && (
          <div className="flex items-center space-x-1 text-xs text-gray-500">
            <div className="w-1.5 h-1.5 bg-gray-400 rounded-full"></div>
            <div className="w-1.5 h-1.5 bg-gray-400 rounded-full"></div>
            <div className="w-1.5 h-1.5 bg-gray-400 rounded-full"></div>
          </div>
        )}
      </div>
      
      <Button
        variant="secondary"
        onClick={() => setPage(currentPage + 1)}
        disabled={!hasMore}
        className={cn(
          "flex items-center space-x-2 transition-all duration-200",
          !hasMore 
            ? "opacity-50 cursor-not-allowed" 
            : "hover:scale-105 hover:shadow-md"
        )}
      >
        <span>Siguiente</span>
        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
        </svg>
      </Button>
    </div>
  </div>
);
</file>

<file path="frontend-nextjs/src/components/dashboard/TablesTab.tsx">
import React from 'react';
import { Button, Card, CardContent, Badge, getStatusBadgeVariant } from '../ui';
import { GRID_LAYOUTS, SPACING, CONTAINER, FLEX, TEXT, cn } from '../../lib/styles';
import { TableFilters } from './Filters';
import { Pagination } from './Pagination';
import type { Table, MenuItem } from '../../types';
import type { TableFilter, TableSort } from '../../hooks/useDashboardData';

interface TablesTabProps {
  // Data
  tablesData?: { tables: Table[] };
  tablesLoading: boolean;
  tablesError: any;
  refetchTables: () => void;
  menuData?: { items: MenuItem[] };
  itemsPerPage: number;
  
  // Count data
  tablesCountData?: { tablesCount: number };
  tablesCountLoading: boolean;
  
  // Filters and sorting
  tableFilter: TableFilter;
  setTableFilter: (filter: TableFilter) => void;
  tableSort: TableSort;
  setTableSort: (sort: TableSort) => void;
  tablePage: number;
  setTablePage: (page: number) => void;
  
  // Actions
  handleAddTable: () => void;
  handleRemoveTable: () => void;
  handleCreateOrder: (tableId: string, itemId: string) => void;
  handleUpdateOrderStatus: (orderId: string, status: string) => void;
  handlePayOrder: (orderId: string) => void;
  handleGenerateQrCode: (tableId: string) => void;
  addTableLoading: boolean;
  removeTableLoading: boolean;
  
  // Utils
  formatPrice: (price: number) => string;
  getErrorMessage: (error: any) => string;
  getQrCodeUrl: (qrCode: string) => string;
  canManageTables: boolean;
}

export const TablesTab: React.FC<TablesTabProps> = ({
  tablesData,
  tablesLoading,
  tablesError,
  refetchTables,
  menuData,
  itemsPerPage,
  tablesCountData,
  tablesCountLoading,
  tableFilter,
  setTableFilter,
  tableSort,
  setTableSort,
  tablePage,
  setTablePage,
  handleAddTable,
  handleRemoveTable,
  handleCreateOrder,
  handleUpdateOrderStatus,
  handlePayOrder,
  handleGenerateQrCode,
  addTableLoading,
  removeTableLoading,
  formatPrice,
  getErrorMessage,
  getQrCodeUrl,
  canManageTables
}) => (
  <div className="p-6 space-y-8">
    {/* Enhanced Header with Analytics */}
    <div className="flex flex-col lg:flex-row lg:items-center lg:justify-between space-y-4 lg:space-y-0">
      <div className="flex items-center space-x-4">
        <div className="p-3 bg-gradient-to-br from-blue-100 to-indigo-100 rounded-2xl">
          <svg className="w-8 h-8 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z" />
          </svg>
        </div>
        <div>
          <h2 className="text-2xl font-bold text-gray-900">Gestión de Mesas</h2>
          <p className="text-gray-600 mt-1">Administra las mesas y su capacidad</p>
        </div>
      </div>
      
      {/* Quick Analytics Cards */}
      <div className="flex flex-wrap gap-3">
        <div className="bg-gradient-to-r from-blue-50 to-indigo-50 border border-blue-200 rounded-xl px-4 py-3 min-w-0 flex items-center space-x-3">
          <div className="w-10 h-10 bg-blue-100 rounded-lg flex items-center justify-center">
            <svg className="w-5 h-5 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 21V5a2 2 0 00-2-2H7a2 2 0 00-2 2v16m14 0h2m-2 0h-5m-9 0H3m2 0h5M9 7h1m-1 4h1m4-4h1m-1 4h1m-5 10v-5a1 1 0 011-1h2a1 1 0 011 1v5m-4 0h4" />
            </svg>
          </div>
          <div>
            <p className="text-sm font-medium text-blue-800">Total Mesas</p>
            <p className="text-lg font-bold text-blue-700">
              {tablesCountLoading ? '...' : (tablesCountData?.tablesCount || 0)}
            </p>
          </div>
        </div>
        
        {tablesData?.tables && tablesData.tables.length > 0 && (
          <>
            <div className="bg-gradient-to-r from-green-50 to-emerald-50 border border-green-200 rounded-xl px-4 py-3 min-w-0 flex items-center space-x-3">
              <div className="w-10 h-10 bg-green-100 rounded-lg flex items-center justify-center">
                <svg className="w-5 h-5 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
              </div>
              <div>
                <p className="text-sm font-medium text-green-800">Con QR</p>
                <p className="text-lg font-bold text-green-700">
                  {tablesData.tables.filter(table => table.qrCode).length}
                </p>
              </div>
            </div>
            
            <div className="bg-gradient-to-r from-purple-50 to-pink-50 border border-purple-200 rounded-xl px-4 py-3 min-w-0 flex items-center space-x-3">
              <div className="w-10 h-10 bg-purple-100 rounded-lg flex items-center justify-center">
                <svg className="w-5 h-5 text-purple-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z" />
                </svg>
              </div>
              <div>
                <p className="text-sm font-medium text-purple-800">Capacidad Total</p>
                <p className="text-lg font-bold text-purple-700">
                  {tablesData.tables.reduce((sum, table) => sum + table.capacity, 0)}
                </p>
              </div>
            </div>
          </>
        )}
      </div>
    </div>

    {/* Management Actions */}
    {canManageTables && (
      <Card className="bg-gradient-to-r from-indigo-50 via-blue-50 to-cyan-50 border-indigo-200 shadow-lg">
        <CardContent className="p-6">
          <div className="flex flex-col sm:flex-row items-center justify-between space-y-4 sm:space-y-0 sm:space-x-4">
            <div className="flex items-center space-x-3">
              <div className="w-8 h-8 bg-indigo-500 rounded-lg flex items-center justify-center">
                <svg className="w-5 h-5 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 6v6m0 0v6m0-6h6m-6 0H6" />
                </svg>
              </div>
              <div>
                <h3 className="text-lg font-semibold text-gray-900">Gestionar Mesas</h3>
                <p className="text-sm text-gray-600">Agregar o eliminar mesas del restaurante</p>
              </div>
            </div>
            <div className="flex space-x-3">
              <Button 
                variant="success"
                onClick={handleAddTable}
                loading={addTableLoading}
                className="flex items-center space-x-2"
              >
                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 6v6m0 0v6m0-6h6m-6 0H6" />
                </svg>
                <span>Agregar Mesa</span>
              </Button>
              <Button 
                variant="danger"
                onClick={handleRemoveTable}
                loading={removeTableLoading}
                className="flex items-center space-x-2"
              >
                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                </svg>
                <span>Eliminar Última</span>
              </Button>
            </div>
          </div>
        </CardContent>
      </Card>
    )}

    {/* Enhanced Filters */}
    <TableFilters 
      filter={tableFilter}
      setFilter={setTableFilter}
      sort={tableSort}
      setSort={setTableSort}
      setPage={setTablePage}
    />

    {/* Enhanced Content Area */}
    {tablesLoading ? (
      <div className="flex flex-col items-center justify-center py-20 space-y-6">
        <div className="relative">
          <div className="w-20 h-20 border-4 border-gray-200 border-t-blue-500 rounded-full animate-spin"></div>
          <div className="absolute inset-0 flex items-center justify-center">
            <svg className="w-8 h-8 text-blue-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z" />
            </svg>
          </div>
        </div>
        <div className="text-center">
          <p className="text-xl font-medium text-gray-600">Cargando mesas...</p>
          <p className="text-sm text-gray-500 mt-1">Obteniendo información de las mesas</p>
        </div>
      </div>
    ) : tablesError ? (
      <div className="bg-gradient-to-r from-red-50 to-red-100 border border-red-200 rounded-2xl p-8">
        <div className="flex items-start space-x-4">
          <div className="flex-shrink-0">
            <div className="w-12 h-12 bg-red-100 rounded-xl flex items-center justify-center">
              <svg className="w-6 h-6 text-red-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
              </svg>
            </div>
          </div>
          <div className="flex-1">
            <h3 className="text-lg font-semibold text-red-800 mb-2">Error cargando mesas</h3>
            <p className="text-red-700 mb-4">{getErrorMessage(tablesError)}</p>
            <Button 
              variant="info"
              onClick={() => refetchTables()}
              className="flex items-center space-x-2"
            >
              <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
              </svg>
              <span>Reintentar</span>
            </Button>
          </div>
        </div>
      </div>
    ) : (
      <>
        {/* Enhanced Tables Grid */}
        {tablesData?.tables.length === 0 ? (
          <div className="flex flex-col items-center justify-center py-20 space-y-6">
            <div className="w-32 h-32 bg-gray-100 rounded-2xl flex items-center justify-center">
              <svg className="w-16 h-16 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z" />
              </svg>
            </div>
            <div className="text-center">
              <h3 className="text-xl font-medium text-gray-900 mb-2">No hay mesas disponibles</h3>
              <p className="text-gray-500 mb-4">Comienza agregando tu primera mesa</p>
              {canManageTables && (
                <p className="text-sm text-gray-400">Usa el botón "Agregar Mesa" de arriba</p>
              )}
            </div>
          </div>
        ) : (
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
            {tablesData?.tables.map((table) => (
              <Card key={table.id} className="transition-all duration-300 hover:shadow-xl hover:-translate-y-1 bg-white">
                <CardContent className="p-6">
                  {/* Table Header */}
                  <div className="flex items-center justify-between mb-4">
                    <div className="flex items-center space-x-3">
                      <div className="w-12 h-12 bg-gradient-to-br from-blue-100 to-indigo-100 rounded-xl flex items-center justify-center">
                        <span className="text-xl font-bold text-blue-600">#{table.number}</span>
                      </div>
                      <div>
                        <h3 className="text-lg font-semibold text-gray-900">Mesa {table.number}</h3>
                        <p className="text-sm text-gray-500">Capacidad: {table.capacity} personas</p>
                      </div>
                    </div>
                    <Badge variant="info" className="flex items-center space-x-1">
                      <svg className="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M16 11V7a4 4 0 00-8 0v4M5 9h14l1 12H4L5 9z" />
                      </svg>
                      <span>{table.orders?.filter(order => order.status !== 'PAID').length || 0} activos</span>
                    </Badge>
                  </div>
                
                  {/* QR Code Section */}
                  <div className="bg-gradient-to-r from-gray-50 to-gray-100 rounded-xl p-4 mb-4">
                    <div className="flex items-center space-x-2 mb-3">
                      <svg className="w-5 h-5 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v1m6 11h-6V4l6 12zM6 4v7h6V4H6z" />
                      </svg>
                      <h4 className="font-medium text-gray-900">Código QR</h4>
                    </div>
                    {table.qrCode ? (
                      <div className="space-y-3">
                        <div className="flex items-center justify-between p-2 bg-white rounded-lg border">
                          <span className="text-xs text-gray-600 font-mono truncate">
                            {table.qrCode}
                          </span>
                          <Button
                            variant="warning"
                            size="xs"
                            onClick={() => handleGenerateQrCode(table.id)}
                            title="Regenerar código QR"
                            className="ml-2"
                          >
                            🔄
                          </Button>
                        </div>
                        <div className="flex gap-2">
                          <a
                            href={getQrCodeUrl(table.qrCode)}
                            target="_blank"
                            rel="noopener noreferrer"
                            className="flex-1 bg-green-600 hover:bg-green-700 text-white font-medium py-2 px-3 rounded-lg text-xs text-center transition-colors"
                          >
                            Ver Menú Público
                          </a>
                          <Button
                            variant="info"
                            size="xs"
                            onClick={() => {
                              navigator.clipboard.writeText(getQrCodeUrl(table.qrCode!));
                              alert('URL copiada al portapapeles');
                            }}
                            title="Copiar URL"
                          >
                            📋
                          </Button>
                        </div>
                      </div>
                    ) : (
                      <Button
                        variant="secondary"
                        size="sm"
                        className="w-full"
                        onClick={() => handleGenerateQrCode(table.id)}
                      >
                        Generar Código QR
                      </Button>
                    )}
                  </div>

                  {/* Quick order form */}
                  <div className="mb-4">
                    <div className="flex items-center space-x-2 mb-3">
                      <svg className="w-5 h-5 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 6v6m0 0v6m0-6h6m-6 0H6" />
                      </svg>
                      <h4 className="font-medium text-gray-900">Pedido Rápido</h4>
                    </div>
                    <div className="flex flex-wrap gap-2">
                      {menuData?.items.slice(0, 3).map((item) => (
                        <Button
                          key={item.id}
                          variant="info"
                          size="xs"
                          onClick={() => handleCreateOrder(table.id, item.id)}
                          className="text-xs"
                          aria-label={`Agregar ${item.name} a mesa ${table.number}`}
                        >
                          {item.name}
                        </Button>
                      ))}
                    </div>
                  </div>

                  {/* Orders in this table */}
                  {table.orders && table.orders.length > 0 && (
                    <div>
                      <div className="flex items-center space-x-2 mb-3">
                        <svg className="w-5 h-5 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M16 11V7a4 4 0 00-8 0v4M5 9h14l1 12H4L5 9z" />
                        </svg>
                        <h4 className="font-medium text-gray-900">Pedidos Actuales</h4>
                      </div>
                      <div className="space-y-3 max-h-48 overflow-y-auto">
                        {table.orders.map((order) => (
                          <div key={order.id} className="bg-white rounded-lg border p-3">
                            <div className="flex items-center justify-between mb-2">
                              <span className="font-medium text-sm">Pedido #{order.id}</span>
                              <Badge variant={getStatusBadgeVariant(order.status)} size="sm">
                                {order.status}
                              </Badge>
                            </div>
                            {order.orderItems?.map((item) => (
                              <p key={item.id} className="text-xs text-gray-600 mb-1">
                                {item.quantity}x {item.menuItem?.name} - {formatPrice(item.price)}
                              </p>
                            ))}
                            {order.status !== 'PAID' && (
                              <div className="flex flex-wrap gap-1 mt-2">
                                <Button
                                  variant="warning"
                                  size="xs"
                                  onClick={() => handleUpdateOrderStatus(order.id, 'PREPARING')}
                                >
                                  Preparando
                                </Button>
                                <Button
                                  variant="info"
                                  size="xs"
                                  onClick={() => handleUpdateOrderStatus(order.id, 'READY')}
                                >
                                  Listo
                                </Button>
                                <Button
                                  variant="success"
                                  size="xs"
                                  onClick={() => handlePayOrder(order.id)}
                                >
                                  Pagar
                                </Button>
                              </div>
                            )}
                          </div>
                        ))}
                      </div>
                    </div>
                  )}
                </CardContent>
              </Card>
            ))}
          </div>
        )}

        {/* Enhanced Pagination */}
        {tablesData?.tables && tablesData.tables.length > 0 && (
          <div className="mt-8">
            <Pagination 
              currentPage={tablePage} 
              setPage={setTablePage} 
              hasMore={tablesData?.tables.length === itemsPerPage}
            />
          </div>
        )}
      </>
    )}
  </div>
);
</file>

<file path="frontend-nextjs/src/hooks/useDashboardActions.ts">
import { useState } from 'react';
import { useDashboardUtils } from './useDashboardUtils';

interface UseDashboardActionsProps {
  createMenuItem: any;
  editMenuItem: any;
  deleteMenuItem: any;
  addTable: any;
  removeTable: any;
  createOrder: any;
  setOrderStatus: any;
  createPayment: any;
  generateQrCode: any;
  refetchMenu: () => void;
  refetchTables: () => void;
  refetchOrders: () => void;
  getErrorMessage: (error: any) => string;
}

export const useDashboardActions = ({
  createMenuItem,
  editMenuItem,
  deleteMenuItem,
  addTable,
  removeTable,
  createOrder,
  setOrderStatus,
  createPayment,
  generateQrCode,
  refetchMenu,
  refetchTables,
  refetchOrders,
  getErrorMessage
}: UseDashboardActionsProps) => {
  const [newItemName, setNewItemName] = useState('');
  const [newItemPrice, setNewItemPrice] = useState('');
  const [newItemImageUrl, setNewItemImageUrl] = useState('');
  const [editingItem, setEditingItem] = useState<{ id: string; name: string; price: string; imageUrl?: string } | null>(null);

  const handleCreateMenuItem = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      await createMenuItem({
        variables: { 
          title: newItemName, 
          price: parseFloat(newItemPrice),
          imageUrl: newItemImageUrl || undefined
        }
      });
      setNewItemName('');
      setNewItemPrice('');
      setNewItemImageUrl('');
      refetchMenu();
    } catch (error) {
      console.error('Error creating menu item:', error);
    }
  };

  const handleEditMenuItem = async (id: string, name: string, price: string, imageUrl?: string) => {
    try {
      await editMenuItem({
        variables: { 
          id, 
          title: name, 
          price: parseFloat(price),
          imageUrl: imageUrl || undefined
        }
      });
      setEditingItem(null);
      refetchMenu();
    } catch (error) {
      console.error('Error editing menu item:', error);
    }
  };

  const handleDeleteMenuItem = async (id: string) => {
    try {
      await deleteMenuItem({ variables: { id } });
      refetchMenu();
    } catch (error) {
      console.error('Error deleting menu item:', error);
    }
  };

  const handleAddTable = async () => {
    try {
      await addTable();
      refetchTables();
    } catch (error: unknown) {
      console.error('Error adding table:', error);
      const errorMessage = getErrorMessage(error as any);
      alert('Error al agregar mesa: ' + errorMessage);
    }
  };

  const handleRemoveTable = async () => {
    try {
      await removeTable();
      refetchTables();
    } catch (error: unknown) {
      console.error('Error removing table:', error);
      const errorMessage = getErrorMessage(error as any);
      alert('Error al eliminar mesa: ' + errorMessage);
    }
  };

  const handleCreateOrder = async (tableId: string, itemId: string) => {
    try {
      await createOrder({ variables: { tableId, itemId } });
      refetchOrders();
      refetchTables();
    } catch (error) {
      console.error('Error creating order:', error);
    }
  };

  const handleUpdateOrderStatus = async (orderId: string, status: string) => {
    try {
      await setOrderStatus({ variables: { id: orderId, status } });
      refetchOrders();
      refetchTables();
    } catch (error) {
      console.error('Error updating order status:', error);
    }
  };

  const handlePayOrder = async (orderId: string) => {
    try {
      await createPayment({ variables: { type: 'CASH', orderId } });
      refetchOrders();
      refetchTables();
    } catch (error) {
      console.error('Error processing payment:', error);
    }
  };

  const handleGenerateQrCode = async (tableId: string) => {
    try {
      await generateQrCode({ variables: { tableId } });
      refetchTables();
    } catch (error) {
      console.error('Error generating QR code:', error);
    }
  };

  const startEditing = (item: { id: string; name: string; price: number; imageUrl?: string }) => {
    setEditingItem({
      id: item.id,
      name: item.name,
      price: item.price.toString(),
      imageUrl: item.imageUrl
    });
  };

  const cancelEditing = () => {
    setEditingItem(null);
  };

  return {
    // Form state
    newItemName,
    setNewItemName,
    newItemPrice,
    setNewItemPrice,
    newItemImageUrl,
    setNewItemImageUrl,
    editingItem,
    setEditingItem,

    // Handlers
    handleCreateMenuItem,
    handleEditMenuItem,
    handleDeleteMenuItem,
    handleAddTable,
    handleRemoveTable,
    handleCreateOrder,
    handleUpdateOrderStatus,
    handlePayOrder,
    handleGenerateQrCode,
    startEditing,
    cancelEditing
  };
};
</file>

<file path="backend/interfaces/graphql/resolvers/menuResolvers.ts">
import { GraphQLContext } from "../context";
import { ListMenuItems } from "../../../application/useCases/ListMenuItems";
import { Cursor } from "../../../domain/valueObjects/Pagination";
import { RoleEnum } from "@prisma/client";
import { requireRole } from "../utils/auth";

export const menuResolvers = {
  Query: {
    menuItems: async (
      _: any,
      args: {
        filter?: {
          name?: string;
          priceMin?: number;
          priceMax?: number;
          isAvailable?: boolean;
        };
        sort?: {
          field: "id" | "name" | "price" | "createdAt" | "isAvailable";
          order: "asc" | "desc";
        };
        first?: number;
        after?: string;
      },
      context: GraphQLContext,
    ) => {
      const listMenuItems = new ListMenuItems(
        context.repositories.menuItemRepository,
      );

      const result = await listMenuItems.execute({
        filter: args.filter,
        sort: args.sort,
        first: args.first,
        after: args.after ? new Cursor(args.after) : undefined,
      });

      return {
        edges: result.edges.map((edge) => ({
          node: edge.node,
          cursor: edge.cursor.value,
        })),
        pageInfo: {
          hasNextPage: result.pageInfo.hasNextPage,
          hasPreviousPage: result.pageInfo.hasPreviousPage,
          startCursor: result.pageInfo.startCursor?.value,
          endCursor: result.pageInfo.endCursor?.value,
        },
      };
    },

    // Add the items field that the frontend expects
    items: async (
      _: unknown,
      args: {
        filter?: {
          name?: string;
          priceMin?: number;
          priceMax?: number;
          isAvailable?: boolean;
        };
        sort?: {
          field: "id" | "name" | "price" | "createdAt" | "isAvailable";
          order: "asc" | "desc";
        };
        limit?: number;
        offset?: number;
      },
      context: GraphQLContext,
    ) => {
      // Convert limit/offset to first/after for the paginated resolver
      const first = args.limit || 50;
      const skip = args.offset || 0;
      
      // Use the existing menuItems resolver but extract just the nodes
      const result = await menuResolvers.Query.menuItems(
        _,
        {
          filter: args.filter,
          sort: args.sort,
          first: first + skip, // Get more items to handle offset
        },
        context,
      );
      
      // Extract just the menu items and apply manual offset
      const items = result.edges.map((edge: { node: unknown }) => edge.node);
      return items.slice(skip, skip + first);
    },

    menuItem: async (_: any, args: { id: number }, context: GraphQLContext) => {
      return context.dataloaders.menuItemLoader.load(args.id);
    },

    menuItemsCount: async (
      _: unknown,
      args: {
        filter?: {
          name?: string;
          priceMin?: number;
          priceMax?: number;
          isAvailable?: boolean;
        };
      },
      context: GraphQLContext,
    ) => {
      return context.repositories.menuItemRepository.count(args.filter);
    },
  },

  Mutation: {
    createItem: async (
      _: unknown,
      args: { title: string; price: number; imageUrl?: string },
      context: GraphQLContext
    ) => {
      requireRole(context, [RoleEnum.MANAGER, RoleEnum.SUPERADMIN]);
      
      return context.repositories.menuItemRepository.create({
        sku: `${args.title.toUpperCase().replace(/\s+/g, '-')}-${Date.now()}`,
        name: args.title,
        price: args.price,
        imageUrl: args.imageUrl,
        isAvailable: true,
      });
    },

    editItem: async (
      _: unknown,
      args: { id: string; title?: string; price?: number; imageUrl?: string },
      context: GraphQLContext
    ) => {
      requireRole(context, [RoleEnum.MANAGER, RoleEnum.SUPERADMIN]);
      
      const updateData: any = {};
      if (args.title !== undefined) updateData.name = args.title;
      if (args.price !== undefined) updateData.price = args.price;
      if (args.imageUrl !== undefined) updateData.imageUrl = args.imageUrl;

      return context.repositories.menuItemRepository.update(Number(args.id), updateData);
    },

    deleteItem: async (
      _: unknown,
      args: { id: string },
      context: GraphQLContext
    ) => {
      requireRole(context, [RoleEnum.MANAGER, RoleEnum.SUPERADMIN]);
      return context.repositories.menuItemRepository.delete(Number(args.id));
    },
  },

  MenuItem: {
    // No additional resolvers needed as all fields are primitive
  },
};
</file>

<file path="backend/repomix-output.xml">
This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
prisma/
  migrations/
    20250424205455_init/
      migration.sql
    20250424232338_init/
      migration.sql
    20250603202909_init/
      migration.sql
    migration_lock.toml
  .env.example
  schema.prisma
  seed.ts
src/
  graphql/
    types.ts
  auth.ts
  context.ts
  prisma.ts
  resolvers.ts
  schema.ts
  server.ts
.gitignore
eslint.config.cjs
package.json
README.md
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="prisma/migrations/20250424205455_init/migration.sql">
-- CreateEnum
CREATE TYPE "Role" AS ENUM ('USER', 'ADMIN');

-- CreateEnum
CREATE TYPE "OrderStatus" AS ENUM ('PENDING', 'PREPARING', 'READY', 'DELIVERED', 'PAID', 'CANCELLED');

-- CreateEnum
CREATE TYPE "PaymentType" AS ENUM ('CASH', 'CARD', 'OTHER');

-- CreateTable
CREATE TABLE "User" (
    "id" SERIAL NOT NULL,
    "email" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "password" TEXT NOT NULL,
    "role" "Role" NOT NULL DEFAULT 'USER',

    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Item" (
    "id" SERIAL NOT NULL,
    "title" TEXT NOT NULL,
    "description" TEXT NOT NULL,
    "imageUrl" TEXT NOT NULL,
    "price" DOUBLE PRECISION NOT NULL,

    CONSTRAINT "Item_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Table" (
    "id" TEXT NOT NULL,
    "number" SERIAL NOT NULL,

    CONSTRAINT "Table_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Order" (
    "id" SERIAL NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "tableId" TEXT NOT NULL,
    "itemId" INTEGER NOT NULL,
    "paymentId" INTEGER,
    "status" "OrderStatus" NOT NULL DEFAULT 'PENDING',

    CONSTRAINT "Order_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Payment" (
    "id" SERIAL NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "type" "PaymentType" NOT NULL,

    CONSTRAINT "Payment_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "User_email_key" ON "User"("email");

-- CreateIndex
CREATE UNIQUE INDEX "Table_number_key" ON "Table"("number");

-- AddForeignKey
ALTER TABLE "Order" ADD CONSTRAINT "Order_tableId_fkey" FOREIGN KEY ("tableId") REFERENCES "Table"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Order" ADD CONSTRAINT "Order_itemId_fkey" FOREIGN KEY ("itemId") REFERENCES "Item"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Order" ADD CONSTRAINT "Order_paymentId_fkey" FOREIGN KEY ("paymentId") REFERENCES "Payment"("id") ON DELETE SET NULL ON UPDATE CASCADE;
</file>

<file path="prisma/migrations/20250424232338_init/migration.sql">
/*
  Warnings:

  - The values [USER] on the enum `Role` will be removed. If these variants are still used in the database, this will fail.

*/
-- AlterEnum
BEGIN;
CREATE TYPE "Role_new" AS ENUM ('SUPERADMIN', 'ADMIN', 'CAJERO', 'MESERO', 'CLIENTE');
ALTER TABLE "User" ALTER COLUMN "role" DROP DEFAULT;
ALTER TABLE "User" ALTER COLUMN "role" TYPE "Role_new" USING ("role"::text::"Role_new");
ALTER TYPE "Role" RENAME TO "Role_old";
ALTER TYPE "Role_new" RENAME TO "Role";
DROP TYPE "Role_old";
ALTER TABLE "User" ALTER COLUMN "role" SET DEFAULT 'CLIENTE';
COMMIT;

-- AlterTable
ALTER TABLE "User" ALTER COLUMN "role" SET DEFAULT 'CLIENTE';
</file>

<file path="prisma/migrations/20250603202909_init/migration.sql">
/*
  Warnings:

  - You are about to alter the column `price` on the `Item` table. The data in that column could be lost. The data in that column will be cast from `DoublePrecision` to `Decimal(65,30)`.

*/
-- AlterTable
ALTER TABLE "Item" ADD COLUMN     "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
ALTER COLUMN "price" SET DATA TYPE DECIMAL(65,30);

-- AlterTable
ALTER TABLE "Table" ADD COLUMN     "capacity" INTEGER DEFAULT 4,
ADD COLUMN     "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP;

-- AlterTable
ALTER TABLE "User" ADD COLUMN     "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP;

-- CreateIndex
CREATE INDEX "Order_tableId_idx" ON "Order"("tableId");

-- CreateIndex
CREATE INDEX "Order_itemId_idx" ON "Order"("itemId");

-- CreateIndex
CREATE INDEX "Order_paymentId_idx" ON "Order"("paymentId");
</file>

<file path="prisma/migrations/migration_lock.toml">
# Please do not edit this file manually
# It should be added in your version-control system (i.e. Git)
provider = "postgresql"
</file>

<file path="prisma/.env.example">
DATABASE_URL="postgresql://usuario:clave@localhost:5432/proyecto_restaurantes"
APP_SECRET="tu_secreto_para_jwt_aquí"
</file>

<file path="prisma/schema.prisma">
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

enum RoleEnum {
  SUPERADMIN
  MANAGER
  STAFF
}

model User {
  id        Int       @id @default(autoincrement())
  email     String    @unique
  password  String
  role      RoleEnum  @default(STAFF)
  createdAt DateTime  @default(now())
  orders    Order[]

  @@map("users")
}

model Table {
  id        Int     @id @default(autoincrement())
  number    Int     @unique
  capacity  Int     @default(4)
  orders    Order[]

  @@map("tables")
}

model MenuItem {
  id          Int       @id @default(autoincrement())
  sku         String    @unique
  name        String
  price       Decimal   @db.Money
  isAvailable Boolean   @default(true)
  createdAt   DateTime  @default(now())
  orderItems  OrderItem[]

  @@map("menu_items")
}

model Order {
  id         Int         @id @default(autoincrement())
  status     String      @default("OPEN")
  tableId    Int
  userId     Int
  createdAt  DateTime    @default(now())
  orderItems OrderItem[]
  payment    Payment?

  table Table @relation(fields: [tableId], references: [id])
  user  User  @relation(fields: [userId], references: [id])

  @@index([status])
  @@map("orders")
}

model OrderItem {
  id         Int     @id @default(autoincrement())
  orderId    Int
  menuItemId Int
  quantity   Int     @default(1)
  price      Decimal  @db.Money

  order    Order    @relation(fields: [orderId], references: [id])
  menuItem MenuItem @relation(fields: [menuItemId], references: [id])

  @@map("order_items")
}

model Payment {
  id        Int      @id @default(autoincrement())
  orderId   Int      @unique
  amount    Decimal  @db.Money
  method    String
  paidAt    DateTime @default(now())

  order Order @relation(fields: [orderId], references: [id])

  @@map("payments")
}
</file>

<file path="prisma/seed.ts">
// prisma/seed.ts
import { PrismaClient, RoleEnum } from '@prisma/client';

const prisma = new PrismaClient();

async function main() {
  // 1. Limpiar tablas dependientes (mantener idempotencia)
  await prisma.$transaction([
    prisma.payment.deleteMany({}),
    prisma.orderItem.deleteMany({}),
    prisma.order.deleteMany({}),
    prisma.table.deleteMany({}),
    prisma.menuItem.deleteMany({}),
    prisma.user.deleteMany({}),
  ]);

  // 2. Usuarios y roles
  const admin = await prisma.user.create({
    data: {
      email: 'admin@food360.local',
      password: '123456hashed', // reemplazar por hash real
      role: RoleEnum.SUPERADMIN,
    },
  });

  // 3. Mesas
  await prisma.table.createMany({
    data: [
      { number: 1, capacity: 4 },
      { number: 2, capacity: 4 },
      { number: 3, capacity: 6 },
      { number: 4, capacity: 2 },
    ],
  });

  // 4. Menú
  await prisma.menuItem.createMany({
    data: [
      { sku: 'QUESADILLA-CLAS', name: 'Quesadilla Clásica', price: 15000 },
      { sku: 'BURGER-ANGUS',   name: 'Hamburguesa Angus',   price: 28000 },
      { sku: 'LIMONADA-MNT',   name: 'Limonada de Menta',   price: 8000  },
    ],
  });

  // 5. Pedido demo
  const order = await prisma.order.create({
    data: {
      status: 'OPEN',
      table: { connect: { number: 1 } },
      user:  { connect: { id: admin.id } },
      orderItems: {
        create: [
          {
            menuItem: { connect: { sku: 'BURGER-ANGUS' } },
            quantity: 2,
            price: 28000,
          },
          {
            menuItem: { connect: { sku: 'LIMONADA-MNT' } },
            quantity: 2,
            price: 8000,
          },
        ],
      },
    },
  });

  // 6. Pago demo
  await prisma.payment.create({
    data: {
      orderId: order.id,
      amount: 2 * 28000 + 2 * 8000,
      method: 'CASH',
    },
  });

  console.log('✅  Seed completed (snake_case)');
}

main()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
</file>

<file path="src/graphql/types.ts">
import { Role } from '@prisma/client';

// src/graphql/types.ts
export interface GetOrdersByTableArgs {
  tableId: string;
}
export interface User {
  id: string;
  name: string;
  email: string;
  role: Role;
}

export interface AuthPayload {
  token: string;
  user: User;
}

export interface Mutation {
  signup(
    email: string,
    password: string,
    name: string,
    role?: Role, // Assuming role is optional based on GraphQL syntax without '!'
  ): AuthPayload;
}
</file>

<file path="src/auth.ts">
// src/auth.ts
import { verify, sign, JwtPayload } from 'jsonwebtoken';
import { Role } from '@prisma/client';

export const APP_SECRET = process.env.APP_SECRET!;

export interface JwtData extends JwtPayload {
  userId: number;
  role: Role;
}

export interface Context {
  userId: number | null;
  role: Role | null;
}

/** Firma el JWT con id y rol */
export function signToken(user: { id: number; role: Role }): string {
  return sign({ userId: user.id, role: user.role }, APP_SECRET, { expiresIn: '7d' });
}

export function getTokenPayload(token: string): JwtData {
  return verify(token, APP_SECRET) as JwtData;
}

export async function authenticate(req: any): Promise<Context> {
  const auth = req.headers.authorization || '';
  if (!auth.startsWith('Bearer ')) return { userId: null, role: null };

  try {
    const { userId, role } = getTokenPayload(auth.replace('Bearer ', ''));
    return { userId, role };
  } catch {
    return { userId: null, role: null };
  }
}

/** Protege un resolver cualquiera — login ya no lo usa */
export function requireAuth(ctx: Context): void {
  if (!ctx.userId) throw new Error('No autorizado');
}

/** Autoriza sólo si el rol actual está incluido en la lista */
export function requireRole(ctx: Context, allowed: Role[]): void {
  requireAuth(ctx);
  if (!ctx.role || !allowed.includes(ctx.role)) {
    throw new Error('Permiso insuficiente');
  }
}
</file>

<file path="src/context.ts">
import { Request } from 'express';
import { authenticate, Context } from './auth';
export async function createContext({ req }: { req: Request }): Promise<Context> {
  return authenticate(req);
}

export type { Context };
</file>

<file path="src/prisma.ts">
import { PrismaClient } from '@prisma/client';
const prisma = new PrismaClient();
export default prisma;
</file>

<file path="src/resolvers.ts">
// src/resolvers.ts
import { Role } from '@prisma/client';
import bcrypt from 'bcryptjs';
import { signToken, requireRole, Context } from './auth';
import prisma from './prisma';

export const resolvers = {
  /* ----------  Queries ---------- */
  Query: {
    // F-02: consultar menú dinámico
    items: (_: unknown, __: unknown) => {
      // público; sin restricciones
      return prisma.item.findMany();
    },
  },

  /* ----------  Mutations ---------- */
  Mutation: {
    // F-01: registro / login
    signup: async (_: any, { email, password, name, role = 'CLIENTE' }: any) => {
      const hashed = await bcrypt.hash(password, 10);
      const user = await prisma.user.create({
        data: { email, name, password: hashed, role },
      });
      return { token: signToken(user), user };
    },

    login: async (_: any, { email, password }: any) => {
      const user = await prisma.user.findUnique({ where: { email } });
      if (!user) throw new Error('Usuario no existe');
      const valid = await bcrypt.compare(password, user.password);
      if (!valid) throw new Error('Contraseña inválida');
      return { token: signToken(user), user };
    },

    // F-03: crear pedido y asignar mesa (dummy)
    createOrder: async (_: any, { tableId, itemId }: any, ctx: Context) => {
      requireRole(ctx, [Role.MESERO, Role.CLIENTE, Role.ADMIN]);

      return prisma.order.create({
        data: { tableId, itemId: Number(itemId) },
        include: {
          table: true,
          item: true,
          payment: true,
        },
      });
    },

    // F-04: procesar pago (dummy)
    createPaymentForOrder: async (_: any, { type, orderId }: any, ctx: Context) => {
      requireRole(ctx, [Role.CAJERO, Role.CLIENTE, Role.ADMIN]);

      // 1. Crea el pago
      const payment = await prisma.payment.create({
        data: { type },
      });

      // 2. Actualiza la orden para asociarla
      await prisma.order.update({
        where: { id: Number(orderId) },
        data: { paymentId: payment.id, status: 'PAID' },
      });

      // 3. Devuelve el pago con la relación 'orders'
      return prisma.payment.findUnique({
        where: { id: payment.id },
        include: {
          orders: {
            include: { table: true, item: true }, // opcional
          },
        },
      });
    },

    // F-05: CRUD menú en panel admin (dummy)
    createItem: (_: any, args: any, ctx: Context) => {
      requireRole(ctx, [Role.ADMIN, Role.SUPERADMIN]);
      return prisma.item.create({ data: args });
    },
    editItem: (_: any, { id, ...patch }: any, ctx: Context) => {
      requireRole(ctx, [Role.ADMIN, Role.SUPERADMIN]);
      return prisma.item.update({
        where: { id: Number(id) },
        data: patch,
      });
    },
    deleteItem: (_: any, { id }: any, ctx: Context) => {
      requireRole(ctx, [Role.ADMIN, Role.SUPERADMIN]);
      return prisma.item.delete({ where: { id: Number(id) } });
    },
    addTable: async (_: any, __: any, ctx: Context) => {
      requireRole(ctx, [Role.ADMIN, Role.MESERO, Role.SUPERADMIN]);
      return prisma.table.create({ data: {} });
    },
  },
};
</file>

<file path="src/schema.ts">
// backend/src/schema.ts

export const typeDefs = /* GraphQL */ `
  type Item {
    id: ID!
    title: String!
    description: String!
    price: Float!
    imageUrl: String!
    orders: [Order!]
  }

  type Table {
    id: ID!
    number: Int!
    orders: [Order!]
  }

  enum OrderStatus {
    PENDING
    PREPARING
    READY
    DELIVERED
    PAID
    CANCELLED
  }

  enum NewOrderStatus {
    PENDING
    PREPARING
    READY
    DELIVERED
  }

  enum PaymentType {
    CASH
    CARD
    OTHER
  }

  type Order {
    id: ID!
    createdAt: String!
    table: Table!
    item: Item!
    payment: Payment
    status: OrderStatus!
  }

  type Payment {
    id: ID!
    createdAt: String!
    type: PaymentType!
    orders: [Order!]!
  }

  type AuthPayload {
    token: String!
    user: User!
  }

  type User {
    id: ID!
    name: String!
    email: String!
    role: String!
  }

  type Query {
    me: User!
    items: [Item!]!
    getItemById(id: ID!): Item
    tables: [Table!]!
    getTableById(id: ID!): Table
    orders: [Order!]!
    getOrdersByTableId(tableId: ID!): [Order!]!
    payments: [Payment!]!
    getPaymentById(id: ID!): Payment
  }

  type Mutation {
    signup(email: String!, password: String!, name: String!): AuthPayload!
    login(email: String!, password: String!): AuthPayload!
    createItem(title: String!, description: String!, price: Float!, imageUrl: String!): Item!
    deleteItem(id: ID!): Item!
    editItem(id: ID!, title: String, description: String, price: Float, imageUrl: String): Item!
    createOrder(tableId: ID!, itemId: ID!, paymentId: ID): Order!
    deleteOrder(id: ID!): Order!
    setOrderStatus(id: ID!, status: NewOrderStatus!): Order!
    cancelOrder(id: ID!): Order!
    createPaymentForOrder(type: PaymentType!, orderId: ID!): Payment!
    createPaymentForTable(type: PaymentType!, tableId: ID!): [Order!]!
    deletePayment(id: ID!): Payment!
    addTable: Table!
    removeTable: Table!
  }
`;
</file>

<file path="src/server.ts">
// src/server.ts
import express, { Request, Response, NextFunction } from 'express';
import cors from 'cors';
import { createServer } from 'http';
import { createYoga, createSchema } from 'graphql-yoga';
import { typeDefs } from './schema';
import { resolvers } from './resolvers';
import { createContext } from './context';
import type { Context } from './auth';

async function main() {
  const app = express();
  app.use(cors());
  app.use(express.json());

  // Construye el esquema GraphQL
  const schema = createSchema({ typeDefs, resolvers });

  // Inicializa Yoga con nuestro contexto tipado
  const yoga = createYoga<Context>({
    schema,
    context: createContext,
    graphiql: true,
  });

  // Middleware puente para que Express reconozca Yoga en /graphql
  app.use('/graphql', (req: Request, res: Response, next: NextFunction) => {
    yoga(req, res).catch(next);
  });

  const port = process.env.PORT ?? 4000;
  createServer(app).listen(port, () => {
    console.log(`🚀 Server listo en http://localhost:${port}/graphql`);
  });
}

main().catch(console.error);
</file>

<file path=".gitignore">
/node_modules
/dist
.env
.DS_Store
.bin
backend/node_modules
/.env
/.DS_Store
/.bin
/.vscode
/.idea
</file>

<file path="eslint.config.cjs">
const { FlatCompat }   = require('@eslint/eslintrc');
const { configs }      = require('@eslint/js');
const tsParser         = require('@typescript-eslint/parser');
const tsPlugin         = require('@typescript-eslint/eslint-plugin');
const prettierPlugin   = require('eslint-plugin-prettier');

const compat = new FlatCompat({
  recommendedConfig: configs.recommended,
  baseDirectory: __dirname
});

module.exports = [
  // 1) Ignorar lo generado y folders externos
  { ignores: ['node_modules/**', 'dist/**', 'prisma/**'] },

  // 2) “Extender” las configs clásicas
  ...compat.extends(
    'eslint:recommended',
    'plugin:@typescript-eslint/recommended',
    'plugin:prettier/recommended'
  ),

  // 3) Plugins, parser y reglas extra
  {
    languageOptions: {
      parser: tsParser,
      parserOptions: {
        project: './tsconfig.json',
        ecmaVersion: 2020,
        sourceType: 'module'
      }
    },
    plugins: {
      '@typescript-eslint': tsPlugin,
      prettier: prettierPlugin
    },
    rules: {
      'prettier/prettier': 'error',
      '@typescript-eslint/no-explicit-any': 'warn',
      '@typescript-eslint/explicit-function-return-type': [
        'error',
        { allowExpressions: true }
      ],
      '@typescript-eslint/no-unused-vars': [
        'error',
        { argsIgnorePattern: '^_' }
      ]
    }
  }
];
</file>

<file path="package.json">
{
  "name": "proyecto-restaurantes-backend",
  "version": "1.0.0",
  "main": "src/server.ts",
  "scripts": {
    "dev": "ts-node-dev --respawn src/server.ts",
    "generate": "prisma generate",
    "migrate": "prisma migrate dev --name init",
    "lint": "eslint .",
    "lint:fix": "eslint . --fix"
  },
  "prisma": {
    "seed": "ts-node --transpile-only prisma/seed.ts"
  },
  "dependencies": {
    "@prisma/client": "^5.0.0",
    "bcryptjs": "^2.4.3",
    "cors": "^2.8.5",
    "express": "^4.18.2",
    "graphql": "^16.6.0",
    "graphql-yoga": "^3.9.1",
    "jsonwebtoken": "^9.0.2"
  },
  "devDependencies": {
    "@types/bcryptjs": "^3.0.0",
    "@types/cors": "^2.8.17",
    "@types/express": "^5.0.1",
    "@types/jsonwebtoken": "^9.0.9",
    "@types/node": "^22.15.29",
    "@typescript-eslint/eslint-plugin": "^8.31.0",
    "@typescript-eslint/parser": "^8.31.0",
    "eslint": "^9.25.1",
    "eslint-config-prettier": "^10.1.2",
    "eslint-plugin-prettier": "^5.2.6",
    "prettier": "^3.5.3",
    "prisma": "^5.0.0",
    "ts-node": "^10.9.2",
    "ts-node-dev": "^2.0.0",
    "typescript": "^5.8.3"
  }
}
</file>

<file path="README.md">
# Proyecto Restaurantes – Backend

Este repositorio contiene el backend mínimo para:
- Autenticación/Autorización (signup, login, JWT)  
- Listar menú, crear pedidos, procesar pagos  
- API GraphQL con Node.js + Express + Prisma + PostgreSQL  

## Cómo arrancar

1. Copiar `backend/prisma/.env.example` a `backend/prisma/.env` y ajustar variables.  
2. `cd backend`  
3. `npm install`  
4. `npx prisma generate`  
5. `npx prisma migrate dev --name init`  
6. `npm run dev`
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "outDir": "dist",
    "rootDir": "src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true
  },
  "include": ["src/**/*"]
}
</file>

</files>
</file>

<file path="backend/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "NodeNext",
    "moduleResolution": "nodenext",
    "outDir": "dist",
    "rootDir": ".",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "resolveJsonModule": true,
    "allowSyntheticDefaultImports": true,
    "forceConsistentCasingInFileNames": true,
    "declaration": false,
    "sourceMap": true,
    "types": ["node", "bcryptjs"]
  },
  "include": [
    "src/**/*",
    "domain/**/*",
    "application/**/*",
    "infrastructure/**/*",
    "interfaces/**/*"
  ],
  "exclude": [
    "node_modules",
    "dist",
    "**/*.test.ts",
    "**/*.spec.ts"
  ]
}
</file>

<file path="frontend-nextjs/src/app/client-provider.tsx">
'use client';

import { ApolloClient, InMemoryCache, createHttpLink, from, ApolloProvider, split } from '@apollo/client';
import { setContext } from '@apollo/client/link/context';
import { onError } from '@apollo/client/link/error';
import { GraphQLWsLink } from '@apollo/client/link/subscriptions';
import { createClient } from 'graphql-ws';
import { getMainDefinition } from '@apollo/client/utilities';

const httpLink = createHttpLink({
  uri: 'http://localhost:4000/graphql',
});

// WebSocket link para suscripciones
const wsLink = typeof window !== 'undefined' ? new GraphQLWsLink(createClient({
  url: 'ws://localhost:4000/graphql',
  connectionParams: () => {
    const token = localStorage.getItem('token');
    return {
      authorization: token ? `Bearer ${token}` : "",
    };
  },
  // Mejorar reconexión automática
  shouldRetry: () => true,
  retryAttempts: 5,
  retryWait: (retries) => {
    return new Promise((resolve) => {
      setTimeout(resolve, Math.min(1000 * Math.pow(2, retries), 30000));
    });
  },
  // Manejo de errores mejorado
  on: {
    error: (error) => console.error('WebSocket error:', error),
  },
})) : null;

const authLink = setContext((_, { headers }) => {
  const token = typeof window !== 'undefined' ? localStorage.getItem('token') : null;
  
  return {
    headers: {
      ...headers,
      authorization: token ? `Bearer ${token}` : "",
      'content-type': 'application/json',
    }
  }
});

const errorLink = onError(({ graphQLErrors, networkError }) => {
  if (graphQLErrors) {
    graphQLErrors.forEach(({ message, locations, path }) =>
      console.log(
        `[GraphQL error]: Message: ${message}, Location: ${locations}, Path: ${path}`
      )
    );
  }

  if (networkError) {
    console.log(`[Network error]: ${networkError}`);
    if (networkError.message.includes('Failed to fetch')) {
      console.error('Backend server is not running on http://localhost:4000/graphql');
    }
  }
});

// Split link to route queries/mutations to HTTP and subscriptions to WebSocket
const splitLink = typeof window !== 'undefined' && wsLink ? split(
  ({ query }) => {
    const definition = getMainDefinition(query);
    return (
      definition.kind === 'OperationDefinition' &&
      definition.operation === 'subscription'
    );
  },
  wsLink,
  from([errorLink, authLink, httpLink])
) : from([errorLink, authLink, httpLink]);

// Export the client instance for direct access when needed
export const apolloClient = new ApolloClient({
  link: splitLink,
  cache: new InMemoryCache({
    typePolicies: {
      Query: {
        fields: {
          orders: {
            // Mejorar cache para actualizaciones en tiempo real
            merge(existing, incoming, { args }) {
              return incoming;
            },
          },
          items: {
            merge(_, incoming) {
              return incoming;
            },
          },
          tables: {
            // Mejorar cache para actualizaciones de mesas
            merge(existing, incoming, { args }) {
              return incoming;
            },
          },
        },
      },
      // Configuración específica para orders
      Order: {
        keyFields: ["id"],
      },
      Table: {
        keyFields: ["id"],
      },
      MenuItem: {
        keyFields: ["id"],
      },
    },
  }),
  defaultOptions: {
    watchQuery: {
      errorPolicy: 'all',
      // Permitir actualizaciones en tiempo real
      notifyOnNetworkStatusChange: true,
    },
    query: {
      errorPolicy: 'all',
    },
  },
});

export default function ClientProvider({
  children,
}: {
  children: React.ReactNode;
}) {
  return <ApolloProvider client={apolloClient}>{children}</ApolloProvider>;
}
</file>

<file path="frontend-nextjs/src/components/dashboard/Filters.tsx">
import React, { useState } from 'react';
import { Button, Input, Card, CardHeader, CardContent } from '../ui';
import { GRID_LAYOUTS, SPACING, TEXT, cn } from '../../lib/styles';
import type { MenuItemFilter, TableFilter, OrderFilter, MenuItemSort, TableSort, OrderSort } from '../../hooks/useDashboardData';

interface MenuFiltersProps {
  filter: MenuItemFilter;
  setFilter: (filter: MenuItemFilter) => void;
  sort: MenuItemSort;
  setSort: (sort: MenuItemSort) => void;
  setPage: (page: number) => void;
}

export const MenuFilters: React.FC<MenuFiltersProps> = ({ filter, setFilter, sort, setSort, setPage }) => {
  const [isExpanded, setIsExpanded] = useState(false);
  const hasActiveFilters = Object.values(filter).some(value => value !== undefined && value !== '');
  const hasActiveSorting = sort.field !== 'name' || sort.order !== 'asc';
  
  return (
    <div className="space-y-3">
      {/* Compact Search Bar */}
      <div className="flex items-center space-x-3">
        <div className="flex-1 relative">
          <input
            type="text"
            value={filter.name || ''}
            onChange={(e) => setFilter({ ...filter, name: e.target.value || undefined })}
            placeholder="Buscar por nombre..."
            className="w-full pl-9 pr-4 py-2 bg-white text-gray-900 placeholder-gray-500 border border-gray-300 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
          />
          <svg className="absolute left-3 top-2.5 w-4 h-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
          </svg>
          {filter.name && (
            <button
              onClick={() => setFilter({ ...filter, name: undefined })}
              className="absolute right-3 top-2.5 text-gray-400 hover:text-gray-600"
            >
              <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>
          )}
        </div>
        
        {/* Filter Toggle Button */}
        <button
          onClick={() => setIsExpanded(!isExpanded)}
          className={cn(
            "flex items-center space-x-2 px-3 py-2 border rounded-lg text-sm font-medium transition-colors",
            (hasActiveFilters || hasActiveSorting) 
              ? "border-blue-500 bg-blue-100 text-blue-800" 
              : "border-gray-400 bg-white text-gray-800 hover:bg-gray-100"
          )}
        >
          <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.414A1 1 0 013 6.707V4z" />
          </svg>
          <span>Filtros</span>
          {(hasActiveFilters || hasActiveSorting) && (
            <span className="bg-blue-600 text-white text-xs rounded-full w-5 h-5 flex items-center justify-center">
              {Object.values(filter).filter(Boolean).length + (hasActiveSorting ? 1 : 0)}
            </span>
          )}
          <svg className={cn("w-4 h-4 transition-transform", isExpanded && "rotate-180")} fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
          </svg>
        </button>
        
        {/* Clear All Button */}
        {(hasActiveFilters || hasActiveSorting) && (
          <button
            onClick={() => {
              setFilter({});
              setSort({ field: 'name', order: 'asc' });
              setPage(0);
            }}
            className="px-3 py-2 text-sm text-gray-800 hover:text-gray-900 bg-gray-100 hover:bg-gray-200 rounded-lg transition-colors"
          >
            Limpiar
          </button>
        )}
      </div>

      {/* Expandable Filters */}
      {isExpanded && (
        <div className="bg-white border border-gray-200 rounded-lg p-4 space-y-4">
          {/* Price Filters */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">Precio</label>
            <div className="grid grid-cols-2 gap-3">
              <input
                type="number"
                value={filter.priceMin || ''}
                onChange={(e) => setFilter({ ...filter, priceMin: e.target.value ? Number(e.target.value) : undefined })}
                placeholder="Mínimo"
                className="px-3 py-2 bg-white text-gray-900 placeholder-gray-500 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-1 focus:ring-blue-500"
              />
              <input
                type="number"
                value={filter.priceMax || ''}
                onChange={(e) => setFilter({ ...filter, priceMax: e.target.value ? Number(e.target.value) : undefined })}
                placeholder="Máximo"
                className="px-3 py-2 bg-white text-gray-900 placeholder-gray-500 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-1 focus:ring-blue-500"
              />
            </div>
          </div>
          
          {/* Availability Filter */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">Disponibilidad</label>
            <select
              value={filter.isAvailable === undefined ? '' : filter.isAvailable.toString()}
              onChange={(e) => setFilter({ ...filter, isAvailable: e.target.value === '' ? undefined : e.target.value === 'true' })}
              className="w-full px-3 py-2 bg-white text-gray-900 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-1 focus:ring-blue-500"
            >
              <option value="">Todos</option>
              <option value="true">Disponible</option>
              <option value="false">No disponible</option>
            </select>
          </div>
          
          {/* Sorting */}
          <div className="border-t pt-4">
            <label className="block text-sm font-medium text-gray-700 mb-2">Ordenar</label>
            <div className="grid grid-cols-2 gap-3">
              <select
                value={sort.field}
                onChange={(e) => setSort({ ...sort, field: e.target.value as MenuItemSort['field'] })}
                className="px-3 py-2 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-1 focus:ring-blue-500"
              >
                <option value="name">Nombre</option>
                <option value="price">Precio</option>
                <option value="createdAt">Fecha</option>
                <option value="isAvailable">Disponibilidad</option>
              </select>
              <select
                value={sort.order}
                onChange={(e) => setSort({ ...sort, order: e.target.value as 'asc' | 'desc' })}
                className="px-3 py-2 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-1 focus:ring-blue-500"
              >
                <option value="asc">A-Z / Menor a mayor</option>
                <option value="desc">Z-A / Mayor a menor</option>
              </select>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

interface TableFiltersProps {
  filter: TableFilter;
  setFilter: (filter: TableFilter) => void;
  sort: TableSort;
  setSort: (sort: TableSort) => void;
  setPage: (page: number) => void;
}

export const TableFilters: React.FC<TableFiltersProps> = ({ filter, setFilter, sort, setSort, setPage }) => {
  const [isExpanded, setIsExpanded] = useState(false);
  const hasActiveFilters = Object.values(filter).some(value => value !== undefined && value !== '');
  const hasActiveSorting = sort.field !== 'number' || sort.order !== 'asc';
  
  return (
    <div className="space-y-3">
      {/* Quick Filters */}
      <div className="flex items-center space-x-3">
        <div className="flex-1">
          <input
            type="number"
            value={filter.number || ''}
            onChange={(e) => setFilter({ ...filter, number: e.target.value ? Number(e.target.value) : undefined })}
            placeholder="Buscar mesa por número..."
            className="w-full px-3 py-2 bg-white text-gray-900 placeholder-gray-500 border border-gray-300 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-blue-500"
          />
        </div>
        
        <button
          onClick={() => setIsExpanded(!isExpanded)}
          className={cn(
            "flex items-center space-x-2 px-3 py-2 border rounded-lg text-sm font-medium transition-colors",
            (hasActiveFilters || hasActiveSorting) 
              ? "border-blue-500 bg-blue-100 text-blue-800" 
              : "border-gray-400 bg-white text-gray-800 hover:bg-gray-100"
          )}
        >
          <span>Filtros</span>
          {(hasActiveFilters || hasActiveSorting) && (
            <span className="bg-blue-600 text-white text-xs rounded-full w-5 h-5 flex items-center justify-center">
              {Object.values(filter).filter(Boolean).length + (hasActiveSorting ? 1 : 0)}
            </span>
          )}
          <svg className={cn("w-4 h-4 transition-transform", isExpanded && "rotate-180")} fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
          </svg>
        </button>
        
        {(hasActiveFilters || hasActiveSorting) && (
          <button
            onClick={() => {
              setFilter({});
              setSort({ field: 'number', order: 'asc' });
              setPage(0);
            }}
            className="px-3 py-2 text-sm text-gray-800 hover:text-gray-900 bg-gray-100 hover:bg-gray-200 rounded-lg transition-colors"
          >
            Limpiar
          </button>
        )}
      </div>

      {isExpanded && (
        <div className="bg-white border border-gray-200 rounded-lg p-4 space-y-4">
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">Capacidad</label>
            <div className="grid grid-cols-2 gap-3">
              <input
                type="number"
                value={filter.capacityMin || ''}
                onChange={(e) => setFilter({ ...filter, capacityMin: e.target.value ? Number(e.target.value) : undefined })}
                placeholder="Mínima"
                className="px-3 py-2 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-1 focus:ring-blue-500"
              />
              <input
                type="number"
                value={filter.capacityMax || ''}
                onChange={(e) => setFilter({ ...filter, capacityMax: e.target.value ? Number(e.target.value) : undefined })}
                placeholder="Máxima"
                className="px-3 py-2 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-1 focus:ring-blue-500"
              />
            </div>
          </div>
          
          <div className="border-t pt-4">
            <label className="block text-sm font-medium text-gray-700 mb-2">Ordenar</label>
            <div className="grid grid-cols-2 gap-3">
              <select
                value={sort.field}
                onChange={(e) => setSort({ ...sort, field: e.target.value as TableSort['field'] })}
                className="px-3 py-2 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-1 focus:ring-blue-500"
              >
                <option value="number">Número</option>
                <option value="capacity">Capacidad</option>
                <option value="orderCount">Pedidos activos</option>
              </select>
              <select
                value={sort.order}
                onChange={(e) => setSort({ ...sort, order: e.target.value as 'asc' | 'desc' })}
                className="px-3 py-2 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-1 focus:ring-blue-500"
              >
                <option value="asc">Menor a mayor</option>
                <option value="desc">Mayor a menor</option>
              </select>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

interface OrderFiltersProps {
  filter: OrderFilter;
  setFilter: (filter: OrderFilter) => void;
  sort: OrderSort;
  setSort: (sort: OrderSort) => void;
  setPage: (page: number) => void;
}

export const OrderFilters: React.FC<OrderFiltersProps> = ({ filter, setFilter, sort, setSort, setPage }) => {
  const [isExpanded, setIsExpanded] = useState(false);
  const hasActiveFilters = Object.values(filter).some(value => value !== undefined && value !== '');
  const hasActiveSorting = sort.field !== 'createdAt' || sort.order !== 'desc';
  
  return (
    <div className="space-y-3">
      {/* Quick Status Filter */}
      <div className="flex items-center space-x-3">
        <div className="flex-1">
          <select
            value={filter.status || ''}
            onChange={(e) => setFilter({ ...filter, status: e.target.value || undefined })}
            className="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-blue-500"
          >
            <option value="">Todos los pedidos</option>
            <option value="PENDING">Pendientes</option>
            <option value="PREPARING">Preparando</option>
            <option value="READY">Listos</option>
            <option value="PAID">Pagados</option>
          </select>
        </div>
        
        <button
          onClick={() => setIsExpanded(!isExpanded)}
          className={cn(
            "flex items-center space-x-2 px-3 py-2 border rounded-lg text-sm font-medium transition-colors",
            (hasActiveFilters || hasActiveSorting) 
              ? "border-blue-500 bg-blue-100 text-blue-800" 
              : "border-gray-300 bg-white text-gray-700 hover:bg-gray-50"
          )}
        >
          <span>Más filtros</span>
          {(hasActiveFilters || hasActiveSorting) && (
            <span className="bg-blue-600 text-white text-xs rounded-full w-5 h-5 flex items-center justify-center">
              {Object.values(filter).filter(Boolean).length + (hasActiveSorting ? 1 : 0)}
            </span>
          )}
          <svg className={cn("w-4 h-4 transition-transform", isExpanded && "rotate-180")} fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
          </svg>
        </button>
        
        {(hasActiveFilters || hasActiveSorting) && (
          <button
            onClick={() => {
              setFilter({});
              setSort({ field: 'createdAt', order: 'desc' });
              setPage(0);
            }}
            className="px-3 py-2 text-sm text-gray-600 hover:text-gray-800"
          >
            Limpiar
          </button>
        )}
      </div>

      {isExpanded && (
        <div className="bg-white border border-gray-200 rounded-lg p-4 space-y-4">
          <div className="grid grid-cols-2 gap-4">
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">Mesa</label>
              <input
                type="number"
                value={filter.tableId || ''}
                onChange={(e) => setFilter({ ...filter, tableId: e.target.value ? Number(e.target.value) : undefined })}
                placeholder="Número de mesa"
                className="w-full px-3 py-2 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-1 focus:ring-blue-500"
              />
            </div>
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">Usuario ID</label>
              <input
                type="number"
                value={filter.userId || ''}
                onChange={(e) => setFilter({ ...filter, userId: e.target.value ? Number(e.target.value) : undefined })}
                placeholder="ID del usuario"
                className="w-full px-3 py-2 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-1 focus:ring-blue-500"
              />
            </div>
          </div>
          
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">Fecha</label>
            <div className="grid grid-cols-2 gap-3">
              <input
                type="datetime-local"
                value={filter.createdAfter ? new Date(filter.createdAfter).toISOString().slice(0, 16) : ''}
                onChange={(e) => setFilter({ ...filter, createdAfter: e.target.value ? new Date(e.target.value).toISOString() : undefined })}
                className="px-3 py-2 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-1 focus:ring-blue-500"
              />
              <input
                type="datetime-local"
                value={filter.createdBefore ? new Date(filter.createdBefore).toISOString().slice(0, 16) : ''}
                onChange={(e) => setFilter({ ...filter, createdBefore: e.target.value ? new Date(e.target.value).toISOString() : undefined })}
                className="px-3 py-2 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-1 focus:ring-blue-500"
              />
            </div>
          </div>
          
          <div className="border-t pt-4">
            <label className="block text-sm font-medium text-gray-700 mb-2">Ordenar</label>
            <div className="grid grid-cols-2 gap-3">
              <select
                value={sort.field}
                onChange={(e) => setSort({ ...sort, field: e.target.value as OrderSort['field'] })}
                className="px-3 py-2 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-1 focus:ring-blue-500"
              >
                <option value="createdAt">Fecha</option>
                <option value="status">Estado</option>
                <option value="tableId">Mesa</option>
                <option value="orderNumber">Número</option>
              </select>
              <select
                value={sort.order}
                onChange={(e) => setSort({ ...sort, order: e.target.value as 'asc' | 'desc' })}
                className="px-3 py-2 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-1 focus:ring-blue-500"
              >
                <option value="desc">Más recientes</option>
                <option value="asc">Más antiguos</option>
              </select>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};
</file>

<file path="backend/interfaces/graphql/resolvers/orderResolvers.ts">
import { GraphQLContext } from "../context";
import { CreateOrderByQrCode } from "../../../application/useCases/CreateOrderByQrCode";
import { UpdateOrderStatus } from "../../../application/useCases/UpdateOrderStatus";
import { OrderStatus } from "../../../domain/entities/Order";
import { RoleEnum } from "@prisma/client";
import { pubsub, SUBSCRIPTION_EVENTS } from "../pubsub";
import { requireRole } from "../utils/auth";

export const orderResolvers = {
  Query: {
    orders: async (
      _: any,
      args: {
        filter?: {
          status?: OrderStatus;
          tableId?: number;
          userId?: number;
          createdAfter?: string;
          createdBefore?: string;
        };
        sort?: {
          field: "id" | "status" | "createdAt" | "tableId";
          order: "asc" | "desc";
        };
        limit?: number;
        offset?: number;
      },
      context: GraphQLContext,
    ) => {
      requireRole(context, [RoleEnum.STAFF, RoleEnum.MANAGER, RoleEnum.SUPERADMIN]);
      
      const filter = args.filter
        ? {
            ...args.filter,
            createdAfter: args.filter.createdAfter
              ? new Date(args.filter.createdAfter)
              : undefined,
            createdBefore: args.filter.createdBefore
              ? new Date(args.filter.createdBefore)
              : undefined,
          }
        : undefined;

      // Use regular pagination instead of cursor pagination
      const orders = await context.repositories.orderRepository.findManyWithPagination(
        filter,
        args.sort,
        args.limit || 12,
        args.offset || 0,
      );

      const totalCount = await context.repositories.orderRepository.count(filter);

      return {
        orders,
        totalCount,
      };
    },

    order: async (_: any, args: { id: number }, context: GraphQLContext) => {
      requireRole(context, [RoleEnum.STAFF, RoleEnum.MANAGER, RoleEnum.SUPERADMIN]);
      return context.dataloaders.orderLoader.load(args.id);
    },

    ordersByQrCode: async (
      _: any,
      args: { qrCode: string },
      context: GraphQLContext,
    ) => {
      return context.repositories.orderRepository.findByQrCode(args.qrCode);
    },

    getOrdersByQrCode: async (
      _: any,
      args: { qrCode: string },
      context: GraphQLContext,
    ) => {
      // Public access for customers
      return context.repositories.orderRepository.findByQrCode(args.qrCode);
    },

    ordersCount: async (
      _: unknown,
      args: {
        filter?: {
          status?: OrderStatus;
          tableId?: number;
          userId?: number;
          createdAfter?: string;
          createdBefore?: string;
        };
      },
      context: GraphQLContext,
    ) => {
      requireRole(context, [RoleEnum.STAFF, RoleEnum.MANAGER, RoleEnum.SUPERADMIN]);
      
      const filter = args.filter
        ? {
            ...args.filter,
            createdAfter: args.filter.createdAfter
              ? new Date(args.filter.createdAfter)
              : undefined,
            createdBefore: args.filter.createdBefore
              ? new Date(args.filter.createdBefore)
              : undefined,
          }
        : undefined;

      return context.repositories.orderRepository.count(filter);
    },

    ordersCountByStatus: async (
      _: unknown,
      args: {},
      context: GraphQLContext,
    ) => {
      requireRole(context, [RoleEnum.STAFF, RoleEnum.MANAGER, RoleEnum.SUPERADMIN]);
      
      const statuses = ['PENDING', 'PREPARING', 'READY', 'PAID', 'CANCELLED'];
      const counts = await Promise.all(
        statuses.map(async (status) => {
          const count = await context.repositories.orderRepository.count({ status: status as OrderStatus });
          return { status, count };
        })
      );
      
      return counts;
    },
  },

  Mutation: {
    createOrder: async (
      _: unknown,
      args: { tableId: string; itemId: string },
      context: GraphQLContext
    ) => {
      requireRole(context, [RoleEnum.STAFF, RoleEnum.MANAGER, RoleEnum.SUPERADMIN]);

      if (!context.user) throw new Error("No autorizado");

      // Create order with single item
      const order = await context.repositories.orderRepository.create({
        tableId: Number(args.tableId),
        status: OrderStatus.PENDING,
        userId: context.user.id,
        items: [{ menuItemId: Number(args.itemId), quantity: 1 }]
      });

      // Publish real-time events
      pubsub.publish(SUBSCRIPTION_EVENTS.ORDER_CREATED, { orderCreated: order });
      pubsub.publish(SUBSCRIPTION_EVENTS.ORDER_UPDATED, { orderUpdated: order });

      return order;
    },

    createOrderByQrCode: async (
      _: any,
      args: {
        qrCode: string;
        items: {
          menuItemId: string;
          quantity: number;
        }[];
      },
      context: GraphQLContext,
    ) => {
      const createOrderByQrCode = new CreateOrderByQrCode(
        context.repositories.orderRepository,
        context.repositories.tableRepository,
        context.repositories.menuItemRepository,
        context.repositories.userRepository,
      );

      const order = await createOrderByQrCode.execute({
        qrCode: args.qrCode,
        items: args.items.map(item => ({
          menuItemId: Number(item.menuItemId),
          quantity: item.quantity
        })),
      });

      // Publish real-time events for QR code orders
      pubsub.publish(SUBSCRIPTION_EVENTS.ORDER_CREATED, { orderCreated: order });
      pubsub.publish(SUBSCRIPTION_EVENTS.ORDER_UPDATED, { orderUpdated: order });

      return order;
    },

    updateOrderStatus: async (
      _: any,
      args: {
        input: {
          orderId: number;
          status: OrderStatus;
        };
      },
      context: GraphQLContext,
    ) => {
      if (!context.user) {
        throw new Error("Authentication required");
      }

      const updateOrderStatus = new UpdateOrderStatus(
        context.repositories.orderRepository,
      );

      const order = await updateOrderStatus.execute({
        orderId: args.input.orderId,
        newStatus: args.input.status,
        user: context.user,
      });

      // Publish real-time events
      pubsub.publish(SUBSCRIPTION_EVENTS.ORDER_STATUS_CHANGED, { orderStatusChanged: order });
      pubsub.publish(SUBSCRIPTION_EVENTS.ORDER_UPDATED, { orderUpdated: order });

      return order;
    },

    setOrderStatus: async (
      _: unknown,
      args: { id: string; status: string },
      context: GraphQLContext
    ) => {
      requireRole(context, [RoleEnum.STAFF, RoleEnum.MANAGER, RoleEnum.SUPERADMIN]);
      
      const order = await context.repositories.orderRepository.updateStatus(
        Number(args.id), 
        args.status as OrderStatus
      );

      // Publish real-time events
      pubsub.publish(SUBSCRIPTION_EVENTS.ORDER_STATUS_CHANGED, { orderStatusChanged: order });
      pubsub.publish(SUBSCRIPTION_EVENTS.ORDER_UPDATED, { orderUpdated: order });

      return order;
    },

    deleteOrder: async (
      _: unknown,
      args: { id: string },
      context: GraphQLContext
    ) => {
      requireRole(context, [RoleEnum.STAFF, RoleEnum.MANAGER, RoleEnum.SUPERADMIN]);
      return context.repositories.orderRepository.delete(Number(args.id));
    },
  },

  Order: {
    table: async (parent: any, _: any, context: GraphQLContext) => {
      return context.dataloaders.tableLoader.load(parent.tableId);
    },

    user: async (parent: any, _: any, context: GraphQLContext) => {
      return context.dataloaders.userLoader.load(parent.userId);
    },

    orderItems: async (parent: any) => {
      return parent.orderItems;
    },

    totalAmount: async (parent: any) => {
      return parent.getTotalAmount();
    },
  },

  OrderItem: {
    menuItem: async (parent: any, _: any, context: GraphQLContext) => {
      return context.dataloaders.menuItemLoader.load(parent.menuItemId);
    },

    total: async (parent: any) => {
      return parent.getTotal();
    },
  },
};
</file>

<file path="frontend-nextjs/src/components/dashboard/MenuTab.tsx">
import React from 'react';
import { Button, Input, Card, CardHeader, CardContent, Badge, getStatusBadgeVariant } from '../ui';
import { GRID_LAYOUTS, SPACING, CONTAINER, FLEX, TEXT, cn } from '../../lib/styles';
import { MenuFilters } from './Filters';
import { Pagination } from './Pagination';
import type { MenuItem } from '../../types';
import type { MenuItemFilter, MenuItemSort } from '../../hooks/useDashboardData';

interface MenuTabProps {
  // Data
  menuData?: { items: MenuItem[] };
  menuLoading: boolean;
  menuError: any;
  refetchMenu: () => void;
  itemsPerPage: number;
  
  // Filters and sorting
  menuFilter: MenuItemFilter;
  setMenuFilter: (filter: MenuItemFilter) => void;
  menuSort: MenuItemSort;
  setMenuSort: (sort: MenuItemSort) => void;
  menuPage: number;
  setMenuPage: (page: number) => void;
  
  // Actions
  newItemName: string;
  setNewItemName: (name: string) => void;
  newItemPrice: string;
  setNewItemPrice: (price: string) => void;
  newItemImageUrl: string;
  setNewItemImageUrl: (url: string) => void;
  handleCreateMenuItem: (e: React.FormEvent) => void;
  handleEditMenuItem: (id: string, name: string, price: string, imageUrl?: string) => void;
  handleDeleteMenuItem: (id: string) => void;
  editingItem: { id: string; name: string; price: string; imageUrl?: string } | null;
  setEditingItem: (item: { id: string; name: string; price: string; imageUrl?: string } | null) => void;
  startEditing: (item: { id: string; name: string; price: number; imageUrl?: string }) => void;
  cancelEditing: () => void;
  
  // Utils
  formatPrice: (price: number) => string;
  getErrorMessage: (error: any) => string;
  canManageMenu: boolean;
}

export const MenuTab: React.FC<MenuTabProps> = ({
  menuData,
  menuLoading,
  menuError,
  refetchMenu,
  itemsPerPage,
  menuFilter,
  setMenuFilter,
  menuSort,
  setMenuSort,
  menuPage,
  setMenuPage,
  newItemName,
  setNewItemName,
  newItemPrice,
  setNewItemPrice,
  newItemImageUrl,
  setNewItemImageUrl,
  handleCreateMenuItem,
  handleEditMenuItem,
  handleDeleteMenuItem,
  editingItem,
  setEditingItem,
  startEditing,
  cancelEditing,
  formatPrice,
  getErrorMessage,
  canManageMenu
}) => (
  <div className="p-6 space-y-6">
    {/* Simple Header */}
    <div className="flex items-center justify-between">
      <div>
        <h2 className="text-2xl font-semibold text-gray-900">Menú</h2>
        <p className="text-gray-600 text-sm mt-1">
          {menuData?.items?.length || 0} platos · {menuData?.items?.filter(item => item.isAvailable).length || 0} disponibles
        </p>
      </div>
    </div>
    
    {/* Add New Item Form */}
    {canManageMenu && (
      <div className="bg-white border border-gray-200 rounded-lg p-4">
        <h3 className="font-medium text-gray-900 mb-4">Agregar nuevo plato</h3>
        <form onSubmit={handleCreateMenuItem} className="space-y-4">
          <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
            <div>
              <label className="block text-sm text-gray-700 mb-1">Nombre del plato</label>
              <input
                type="text"
                value={newItemName}
                onChange={(e) => setNewItemName(e.target.value)}
                required
                placeholder="Ej: Bandeja paisa"
                className="w-full px-3 py-2 bg-white text-gray-900 placeholder-gray-500 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-1 focus:ring-blue-500 focus:border-blue-500"
              />
            </div>
            <div>
              <label className="block text-sm text-gray-700 mb-1">Precio (COP)</label>
              <input
                type="number"
                value={newItemPrice}
                onChange={(e) => setNewItemPrice(e.target.value)}
                required
                min="0"
                step="100"
                placeholder="25000"
                className="w-full px-3 py-2 bg-white text-gray-900 placeholder-gray-500 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-1 focus:ring-blue-500 focus:border-blue-500"
              />
            </div>
            <div>
              <label className="block text-sm text-gray-700 mb-1">URL de imagen (opcional)</label>
              <input
                type="url"
                value={newItemImageUrl}
                onChange={(e) => setNewItemImageUrl(e.target.value)}
                placeholder="https://ejemplo.com/imagen.jpg"
                className="w-full px-3 py-2 bg-white text-gray-900 placeholder-gray-500 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-1 focus:ring-blue-500 focus:border-blue-500"
              />
            </div>
          </div>
          <div className="flex justify-end">
            <button 
              type="submit" 
              className="px-4 py-2 bg-blue-600 text-white text-sm font-medium rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500"
            >
              Agregar
            </button>
          </div>
        </form>
      </div>
    )}

    {/* Compact Filters */}
    <MenuFilters 
      filter={menuFilter}
      setFilter={setMenuFilter}
      sort={menuSort}
      setSort={setMenuSort}
      setPage={setMenuPage}
    />

    {/* Content */}
    {menuLoading ? (
      <div className="flex items-center justify-center py-12">
        <div className="w-6 h-6 border-2 border-gray-300 border-t-blue-600 rounded-full animate-spin"></div>
        <span className="ml-3 text-gray-600">Cargando...</span>
      </div>
    ) : menuError ? (
      <div className="bg-red-50 border border-red-200 rounded-lg p-4">
        <p className="text-red-800 font-medium">Error al cargar el menú</p>
        <p className="text-red-600 text-sm mt-1">{getErrorMessage(menuError)}</p>
        <button 
          onClick={() => refetchMenu()}
          className="mt-3 px-3 py-1 bg-red-100 text-red-800 text-sm rounded hover:bg-red-200"
        >
          Reintentar
        </button>
      </div>
    ) : (
      <>
        {menuData?.items.length === 0 ? (
          <div className="text-center py-12">
            <p className="text-gray-500">No hay platos en el menú</p>
            {canManageMenu && (
              <p className="text-gray-400 text-sm mt-1">Agrega el primer plato usando el formulario de arriba</p>
            )}
          </div>
        ) : (
          <div className="space-y-3">
            {menuData?.items.map((item) => (
              <div key={item.id} className="bg-white border border-gray-200 rounded-lg overflow-hidden hover:shadow-sm transition-shadow">
                <div className="flex">
                  {/* Image section */}
                  <div className="w-24 h-24 flex-shrink-0 bg-gray-100">
                    {item.imageUrl ? (
                      <img 
                        src={item.imageUrl} 
                        alt={item.name}
                        className="w-full h-full object-cover"
                        onError={(e) => {
                          e.currentTarget.src = 'https://images.unsplash.com/photo-1546833999-b9f581a1996d?w=400&h=300&fit=crop';
                        }}
                      />
                    ) : (
                      <div className="w-full h-full flex items-center justify-center bg-gray-200">
                        <svg className="w-8 h-8 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
                        </svg>
                      </div>
                    )}
                  </div>
                  
                  {/* Content section */}
                  <div className="flex-1 p-4">
                    <div className="flex items-center justify-between">
                      <div className="flex-1">
                        <div className="flex items-center space-x-3">
                          <h3 className="font-medium text-gray-900">{item.name}</h3>
                          <span className={`px-2 py-1 text-xs rounded-full ${
                            item.isAvailable 
                              ? 'bg-green-100 text-green-800' 
                              : 'bg-red-100 text-red-800'
                          }`}>
                            {item.isAvailable ? 'Disponible' : 'Agotado'}
                          </span>
                        </div>
                        <p className="text-gray-500 text-sm mt-1">SKU: {item.sku}</p>
                      </div>
                      
                      <div className="flex items-center space-x-4">
                        <span className="font-semibold text-gray-900">{formatPrice(item.price)}</span>
                        {canManageMenu && (
                          <div className="flex items-center space-x-2">
                            <button
                              onClick={() => startEditing({ id: item.id, name: item.name, price: item.price, imageUrl: item.imageUrl })}
                              className="text-blue-600 hover:text-blue-800 text-sm"
                            >
                              Editar
                            </button>
                            <button
                              onClick={() => handleDeleteMenuItem(item.id)}
                              className="text-red-600 hover:text-red-800 text-sm"
                            >
                              Eliminar
                            </button>
                          </div>
                        )}
                      </div>
                    </div>

                    {/* Edit Item Form - Shown only when editing */}
                    {editingItem?.id === item.id && (
                      <div className="mt-4">
                        <form 
                          onSubmit={(e) => {
                            e.preventDefault();
                            handleEditMenuItem(item.id, editingItem.name, editingItem.price, editingItem.imageUrl);
                          }}
                          className="space-y-4"
                        >
                          <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                            <div>
                              <label className="block text-sm text-gray-700 mb-1">Nombre del plato</label>
                              <input
                                type="text"
                                value={editingItem.name}
                                onChange={(e) => setEditingItem({ ...editingItem, name: e.target.value })}
                                required
                                className="w-full px-3 py-2 bg-white text-gray-900 placeholder-gray-500 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-1 focus:ring-blue-500 focus:border-blue-500"
                              />
                            </div>
                            <div>
                              <label className="block text-sm text-gray-700 mb-1">Precio (COP)</label>
                              <input
                                type="number"
                                value={editingItem.price}
                                onChange={(e) => setEditingItem({ ...editingItem, price: e.target.value })}
                                required
                                min="0"
                                step="100"
                                className="w-full px-3 py-2 bg-white text-gray-900 placeholder-gray-500 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-1 focus:ring-blue-500 focus:border-blue-500"
                              />
                            </div>
                            <div>
                              <label className="block text-sm text-gray-700 mb-1">URL de imagen</label>
                              <input
                                type="url"
                                value={editingItem.imageUrl || ''}
                                onChange={(e) => setEditingItem({ ...editingItem, imageUrl: e.target.value })}
                                placeholder="https://ejemplo.com/imagen.jpg"
                                className="w-full px-3 py-2 bg-white text-gray-900 placeholder-gray-500 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-1 focus:ring-blue-500 focus:border-blue-500"
                              />
                            </div>
                          </div>
                          <div className="flex justify-end gap-2">
                            <button 
                              type="button"
                              onClick={cancelEditing}
                              className="px-4 py-2 bg-gray-200 text-gray-700 text-sm font-medium rounded-md hover:bg-gray-300 focus:outline-none"
                            >
                              Cancelar
                            </button>
                            <button 
                              type="submit" 
                              className="px-4 py-2 bg-blue-600 text-white text-sm font-medium rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500"
                            >
                              Guardar
                            </button>
                          </div>
                        </form>
                      </div>
                    )}
                  </div>
                </div>
              </div>
            ))}
          </div>
        )}

        {/* Pagination */}
        {menuData?.items && menuData.items.length > 0 && (
          <div className="flex justify-center pt-4">
            <Pagination 
              currentPage={menuPage} 
              setPage={setMenuPage} 
              hasMore={menuData?.items.length === itemsPerPage}
            />
          </div>
        )}
      </>
    )}
  </div>
);
</file>

<file path="frontend-nextjs/src/hooks/useDashboardData.ts">
import { useState } from 'react';
import { useQuery, useMutation, useSubscription } from '@apollo/client';
import { 
  GET_MENU_ITEMS, 
  GET_TABLES, 
  GET_ORDERS,
  GET_MENU_ITEMS_COUNT,
  GET_TABLES_COUNT,
  GET_ORDERS_COUNT,
  GET_ORDERS_COUNT_BY_STATUS,
  CREATE_MENU_ITEM,
  EDIT_MENU_ITEM,
  DELETE_MENU_ITEM,
  ADD_TABLE,
  REMOVE_TABLE,
  CREATE_ORDER,
  SET_ORDER_STATUS,
  CREATE_PAYMENT_FOR_ORDER,
  GET_ME,
  GENERATE_QR_CODE_FOR_TABLE,
  ORDER_CREATED_SUBSCRIPTION,
  ORDER_UPDATED_SUBSCRIPTION,
  ORDER_STATUS_CHANGED_SUBSCRIPTION
} from '../lib/queries';
import type { MenuItem, Table, Order, User } from '../types';

// Filter interfaces
export interface MenuItemFilter {
  name?: string;
  priceMin?: number;
  priceMax?: number;
  isAvailable?: boolean;
}

export interface TableFilter {
  number?: number;
  capacityMin?: number;
  capacityMax?: number;
  hasQrCode?: boolean;
}

export interface OrderFilter {
  status?: string;
  tableId?: number;
  userId?: number;
  createdAfter?: string;
  createdBefore?: string;
}

// Sort interfaces
export interface MenuItemSort {
  field: 'id' | 'name' | 'price' | 'createdAt' | 'isAvailable';
  order: 'asc' | 'desc';
}

export interface TableSort {
  field: 'id' | 'number' | 'capacity' | 'orderCount';
  order: 'asc' | 'desc';
}

export interface OrderSort {
  field: 'id' | 'status' | 'createdAt' | 'tableId' | 'orderNumber';
  order: 'asc' | 'desc';
}

export const useDashboardData = () => {
  // Filter and sort states
  const [menuFilter, setMenuFilter] = useState<MenuItemFilter>({});
  const [menuSort, setMenuSort] = useState<MenuItemSort>({ field: 'name', order: 'asc' });
  const [tableFilter, setTableFilter] = useState<TableFilter>({});
  const [tableSort, setTableSort] = useState<TableSort>({ field: 'number', order: 'asc' });
  const [orderFilter, setOrderFilter] = useState<OrderFilter>({});
  const [orderSort, setOrderSort] = useState<OrderSort>({ field: 'createdAt', order: 'desc' });

  // Pagination states
  const [menuPage, setMenuPage] = useState(0);
  const [tablePage, setTablePage] = useState(0);
  const [orderPage, setOrderPage] = useState(0);
  const itemsPerPage = 12;

  // Queries with filters and sorting
  const { data: userData, loading: userLoading, error: userError } = useQuery<{ me: User }>(GET_ME);
  
  const { data: menuData, loading: menuLoading, error: menuError, refetch: refetchMenu } = useQuery<{ items: MenuItem[] }>(GET_MENU_ITEMS, {
    variables: {
      filter: Object.keys(menuFilter).length > 0 ? menuFilter : undefined,
      sort: menuSort,
      limit: itemsPerPage,
      offset: menuPage * itemsPerPage
    }
  });

  const { data: tablesData, loading: tablesLoading, error: tablesError, refetch: refetchTables } = useQuery<{ tables: Table[] }>(GET_TABLES, {
    variables: {
      filter: Object.keys(tableFilter).length > 0 ? tableFilter : undefined,
      sort: tableSort,
      limit: itemsPerPage,
      offset: tablePage * itemsPerPage
    }
  });

  const { data: ordersData, loading: ordersLoading, error: ordersError, refetch: refetchOrders } = useQuery(GET_ORDERS, {
    variables: {
      filter: Object.keys(orderFilter).length > 0 ? orderFilter : undefined,
      sort: orderSort,
      limit: itemsPerPage,
      offset: orderPage * itemsPerPage,
    },
  });

  // Count queries for totals
  const { data: menuCountData, loading: menuCountLoading } = useQuery<{ menuItemsCount: number }>(GET_MENU_ITEMS_COUNT, {
    variables: {
      filter: Object.keys(menuFilter).length > 0 ? menuFilter : undefined,
    }
  });

  const { data: tablesCountData, loading: tablesCountLoading } = useQuery<{ tablesCount: number }>(GET_TABLES_COUNT, {
    variables: {
      filter: Object.keys(tableFilter).length > 0 ? tableFilter : undefined,
    }
  });

  const { data: ordersCountData, loading: ordersCountLoading } = useQuery<{ ordersCount: number }>(GET_ORDERS_COUNT, {
    variables: {
      filter: Object.keys(orderFilter).length > 0 ? orderFilter : undefined,
    }
  });

  // Order counts by status for accurate status cards
  const { data: ordersCountByStatusData, loading: ordersCountByStatusLoading } = useQuery<{ 
    ordersCountByStatus: Array<{ status: string; count: number }> 
  }>(GET_ORDERS_COUNT_BY_STATUS);

  // Mutations
  const [createMenuItem] = useMutation(CREATE_MENU_ITEM);
  const [editMenuItem] = useMutation(EDIT_MENU_ITEM);
  const [deleteMenuItem] = useMutation(DELETE_MENU_ITEM);
  const [addTable, { loading: addTableLoading }] = useMutation(ADD_TABLE);
  const [removeTable, { loading: removeTableLoading }] = useMutation(REMOVE_TABLE);
  const [createOrder] = useMutation(CREATE_ORDER);
  const [setOrderStatus] = useMutation(SET_ORDER_STATUS);
  const [createPayment] = useMutation(CREATE_PAYMENT_FOR_ORDER);
  const [generateQrCode] = useMutation(GENERATE_QR_CODE_FOR_TABLE);

  // Subscriptions
  useSubscription(ORDER_CREATED_SUBSCRIPTION, {
    onSubscriptionData: ({ subscriptionData }) => {
      if (subscriptionData.data?.orderCreated) {
        refetchOrders();
        refetchTables();
      }
    },
    onError: (error) => {
      console.error('Order created subscription error:', error);
    }
  });

  useSubscription(ORDER_UPDATED_SUBSCRIPTION, {
    onSubscriptionData: ({ subscriptionData }) => {
      if (subscriptionData.data?.orderUpdated) {
        refetchOrders();
        refetchTables();
      }
    },
    onError: (error) => {
      console.error('Order updated subscription error:', error);
    }
  });

  useSubscription(ORDER_STATUS_CHANGED_SUBSCRIPTION, {
    onSubscriptionData: ({ subscriptionData }) => {
      if (subscriptionData.data?.orderStatusChanged) {
        refetchOrders();
        refetchTables();
      }
    },
    onError: (error) => {
      console.error('Order status changed subscription error:', error);
    }
  });

  return {
    // User data
    userData,
    userLoading,
    userError,

    // Menu data
    menuData,
    menuLoading,
    menuError,
    refetchMenu,
    menuFilter,
    setMenuFilter,
    menuSort,
    setMenuSort,
    menuPage,
    setMenuPage,

    // Table data
    tablesData,
    tablesLoading,
    tablesError,
    refetchTables,
    tableFilter,
    setTableFilter,
    tableSort,
    setTableSort,
    tablePage,
    setTablePage,

    // Order data
    ordersData,
    ordersLoading,
    ordersError,
    refetchOrders,
    orderFilter,
    setOrderFilter,
    orderSort,
    setOrderSort,
    orderPage,
    setOrderPage,

    // Count data
    menuCountData,
    menuCountLoading,
    tablesCountData,
    tablesCountLoading,
    ordersCountData,
    ordersCountLoading,
    ordersCountByStatusData,
    ordersCountByStatusLoading,

    // Mutations
    createMenuItem,
    editMenuItem,
    deleteMenuItem,
    addTable,
    addTableLoading,
    removeTable,
    removeTableLoading,
    createOrder,
    setOrderStatus,
    createPayment,
    generateQrCode,

    // Constants
    itemsPerPage
  };
};
</file>

<file path="frontend-nextjs/src/lib/queries.ts">
import { gql } from '@apollo/client';

// Auth mutations
export const LOGIN_MUTATION = gql`
  mutation LoginUsuario($email: String!, $password: String!) {
    login(email: $email, password: $password) {
      token
      user {
        id
        email
        role
      }
    }
  }
`;

export const SIGNUP_MUTATION = gql`
  mutation SignupUsuario($email: String!, $password: String!, $name: String, $role: RoleEnum) {
    signup(email: $email, password: $password, name: $name, role: $role) {
      token
      user {
        id
        email
        role
      }
    }
  }
`;

// Menu queries and mutations
export const GET_MENU_ITEMS = gql`
  query VerMenu($filter: MenuItemFilter, $sort: MenuItemSort, $limit: Int, $offset: Int) {
    items(filter: $filter, sort: $sort, limit: $limit, offset: $offset) {
      id
      sku
      name
      price
      imageUrl
      isAvailable
      createdAt
    }
  }
`;

export const CREATE_MENU_ITEM = gql`
  mutation CrearMenuItem($title: String!, $price: Float!, $imageUrl: String) {
    createItem(title: $title, price: $price, imageUrl: $imageUrl) {
      id
      sku
      name
      price
      imageUrl
      isAvailable
      createdAt
    }
  }
`;

export const EDIT_MENU_ITEM = gql`
  mutation EditarMenuItem($id: ID!, $title: String, $price: Float, $imageUrl: String) {
    editItem(id: $id, title: $title, price: $price, imageUrl: $imageUrl) {
      id
      sku
      name
      price
      imageUrl
      isAvailable
      createdAt
    }
  }
`;

export const DELETE_MENU_ITEM = gql`
  mutation EliminarMenuItem($id: ID!) {
    deleteItem(id: $id) {
      id
      name
    }
  }
`;

// Count queries
export const GET_MENU_ITEMS_COUNT = gql`
  query ContarMenuItems($filter: MenuItemFilter) {
    menuItemsCount(filter: $filter)
  }
`;

export const GET_TABLES_COUNT = gql`
  query ContarMesas($filter: TableFilter) {
    tablesCount(filter: $filter)
  }
`;

export const GET_ORDERS_COUNT = gql`
  query ContarPedidos($filter: OrderFilter) {
    ordersCount(filter: $filter)
  }
`;

export const GET_ORDERS_COUNT_BY_STATUS = gql`
  query ContarPedidosPorEstado {
    ordersCountByStatus {
      status
      count
    }
  }
`;

// Tables queries and mutations
export const GET_TABLES = gql`
  query VerMesas($filter: TableFilter, $sort: TableSort, $limit: Int, $offset: Int) {
    tables(filter: $filter, sort: $sort, limit: $limit, offset: $offset) {
      id
      number
      capacity
      qrCode
      orders {
        id
        status
        tableId
        userId
        createdAt
        orderItems {
          id
          quantity
          price
          menuItem {
            id
            name
            price
            imageUrl
          }
        }
      }
    }
  }
`;

export const ADD_TABLE = gql`
  mutation AgregarMesa {
    addTable {
      id
      number
      capacity
    }
  }
`;

export const REMOVE_TABLE = gql`
  mutation EliminarUltimaMesa {
    removeTable {
      id
      number
      capacity
    }
  }
`;

// Orders queries and mutations
export const GET_ORDERS = gql`
  query VerPedidos($filter: OrderFilter, $sort: OrderSort, $limit: Int, $offset: Int) {
    orders(filter: $filter, sort: $sort, limit: $limit, offset: $offset) {
      orders {
        id
        status
        tableId
        userId
        createdAt
        orderItems {
          id
          quantity
          price
          menuItem {
            id
            name
            price
            imageUrl
          }
        }
        table {
          id
          number
        }
        user {
          id
          email
        }
      }
      totalCount
    }
  }
`;

export const CREATE_ORDER = gql`
  mutation CrearPedido($tableId: ID!, $itemId: ID!) {
    createOrder(tableId: $tableId, itemId: $itemId) {
      id
      status
      tableId
      userId
      createdAt
      orderItems {
        id
        quantity
        price
        menuItem {
          id
          name
          price
          imageUrl
        }
      }
    }
  }
`;

export const SET_ORDER_STATUS = gql`
  mutation CambiarEstadoPedido($id: ID!, $status: String!) {
    setOrderStatus(id: $id, status: $status) {
      id
      status
      tableId
      userId
      createdAt
    }
  }
`;

// Payments mutations
export const CREATE_PAYMENT_FOR_ORDER = gql`
  mutation ProcesarPagoPedido($type: String!, $orderId: ID!) {
    createPaymentForOrder(type: $type, orderId: $orderId) {
      id
      orderId
      amount
      method
      paidAt
    }
  }
`;

export const CREATE_PAYMENT_FOR_TABLE = gql`
  mutation ProcesarPagoMesa($type: String!, $tableId: ID!) {
    createPaymentForTable(type: $type, tableId: $tableId) {
      id
      status
      tableId
      userId
      createdAt
    }
  }
`;

// User query
export const GET_ME = gql`
  query UsuarioActual {
    me {
      id
      email
      role
      createdAt
    }
  }
`;

// QR Code queries and mutations
export const GET_TABLE_BY_QR_CODE = gql`
  query GetTableByQrCode($qrCode: String!) {
    getTableByQrCode(qrCode: $qrCode) {
      id
      number
      capacity
      qrCode
    }
  }
`;

export const GET_ORDERS_BY_QR_CODE = gql`
  query GetOrdersByQrCode($qrCode: String!) {
    getOrdersByQrCode(qrCode: $qrCode) {
      id
      status
      tableId
      userId
      createdAt
      orderItems {
        id
        quantity
        price
        menuItem {
          id
          name
          price
          imageUrl
        }
      }
    }
  }
`;

export const CREATE_ORDER_BY_QR_CODE = gql`
  mutation CreateOrderByQrCode($qrCode: String!, $items: [OrderItemInput!]!) {
    createOrderByQrCode(qrCode: $qrCode, items: $items) {
      id
      status
      tableId
      userId
      createdAt
      orderItems {
        id
        quantity
        price
        menuItem {
          id
          name
          price
          imageUrl
        }
      }
    }
  }
`;

export const GENERATE_QR_CODE_FOR_TABLE = gql`
  mutation GenerateQrCodeForTable($tableId: ID!) {
    generateQrCodeForTable(tableId: $tableId) {
      id
      number
      capacity
      qrCode
    }
  }
`;

// Real-time subscriptions for orders
export const ORDER_CREATED_SUBSCRIPTION = gql`
  subscription OnOrderCreated {
    orderCreated {
      id
      status
      tableId
      userId
      createdAt
      orderItems {
        id
        quantity
        price
        menuItem {
          id
          name
          price
          imageUrl
        }
      }
      table {
        id
        number
      }
      user {
        id
        email
      }
    }
  }
`;

export const ORDER_UPDATED_SUBSCRIPTION = gql`
  subscription OnOrderUpdated {
    orderUpdated {
      id
      status
      tableId
      userId
      createdAt
      orderItems {
        id
        quantity
        price
        menuItem {
          id
          name
          price
          imageUrl
        }
      }
      table {
        id
        number
      }
      user {
        id
        email
      }
    }
  }
`;

export const ORDER_STATUS_CHANGED_SUBSCRIPTION = gql`
  subscription OnOrderStatusChanged {
    orderStatusChanged {
      id
      status
      tableId
      userId
      createdAt
      orderItems {
        id
        quantity
        price
        menuItem {
          id
          name
          price
          imageUrl
        }
      }
      table {
        id
        number
      }
      user {
        id
        email
      }
    }
  }
`;
</file>

<file path="frontend-nextjs/src/components/dashboard/OrdersTab.tsx">
import React from 'react';
import { Button, Card, CardContent, Badge, getStatusBadgeVariant } from '../ui';
import { GRID_LAYOUTS, SPACING, CONTAINER, FLEX, TEXT, cn } from '../../lib/styles';
import { OrderFilters } from './Filters';
import { Pagination } from './Pagination';
import type { Order } from '../../types';
import type { OrderFilter, OrderSort } from '../../hooks/useDashboardData';

interface OrdersTabProps {
  // Data
  ordersData?: {
    orders: {
      orders: Order[];
      totalCount: number;
    };
  };
  ordersLoading: boolean;
  ordersError: any;
  refetchOrders: () => void;
  
  // Pagination
  currentPage: number;
  setPage: (page: number) => void;
  hasMore: boolean;
  
  // Filters and sorting
  orderFilter: OrderFilter;
  setOrderFilter: (filter: OrderFilter) => void;
  orderSort: OrderSort;
  setOrderSort: (sort: OrderSort) => void;
  
  // Actions
  handleUpdateOrderStatus: (orderId: string, status: string) => void;
  handlePayOrder: (orderId: string) => void;
  
  // Count data
  ordersCountByStatusData?: {
    ordersCountByStatus: Array<{ status: string; count: number }>;
  };
  ordersCountByStatusLoading: boolean;
  
  // Utils
  formatPrice: (price: number) => string;
  getErrorMessage: (error: any) => string;
}

export const OrdersTab: React.FC<OrdersTabProps> = ({
  ordersData,
  ordersLoading,
  ordersError,
  refetchOrders,
  currentPage,
  setPage,
  hasMore,
  orderFilter,
  setOrderFilter,
  orderSort,
  setOrderSort,
  handleUpdateOrderStatus,
  handlePayOrder,
  ordersCountByStatusData,
  ordersCountByStatusLoading,
  formatPrice,
  getErrorMessage
}) => {
  const orders = ordersData?.orders?.orders || [];
  
  // Use real status counts from the backend instead of calculating from current page
  const statusCounts = ordersCountByStatusData?.ordersCountByStatus?.reduce((acc, item) => {
    acc[item.status] = item.count;
    return acc;
  }, {} as Record<string, number>) || {};

  const totalRevenue = orders
    .filter(order => order.status === 'PAID')
    .reduce((sum, order) => {
      return sum + (order.orderItems?.reduce((itemSum, item) => itemSum + (item.price * item.quantity), 0) || 0);
    }, 0);

  return (
    <div className="p-6 space-y-8">
      {/* Enhanced Header with Analytics */}
      <div className="flex flex-col lg:flex-row lg:items-center lg:justify-between space-y-4 lg:space-y-0">
        <div className="flex items-center space-x-4">
          <div className="p-3 bg-gradient-to-br from-green-100 to-teal-100 rounded-2xl">
            <svg className="w-8 h-8 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M16 11V7a4 4 0 00-8 0v4M5 9h14l1 12H4L5 9z" />
            </svg>
          </div>
          <div>
            <h2 className="text-2xl font-bold text-gray-900">Gestión de Pedidos</h2>
            <p className="text-gray-600 mt-1">Monitorea y administra todos los pedidos</p>
          </div>
        </div>
        
        {/* Quick Analytics Cards */}
        <div className="flex flex-wrap gap-3">
          <div className="bg-gradient-to-r from-blue-50 to-indigo-50 border border-blue-200 rounded-xl px-4 py-3 min-w-0 flex items-center space-x-3">
            <div className="w-10 h-10 bg-blue-100 rounded-lg flex items-center justify-center">
              <svg className="w-5 h-5 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2" />
              </svg>
            </div>
            <div>
              <p className="text-sm font-medium text-blue-800">Total</p>
              <p className="text-lg font-bold text-blue-700">{orders.length}</p>
            </div>
          </div>
          
          <div className="bg-gradient-to-r from-yellow-50 to-orange-50 border border-yellow-200 rounded-xl px-4 py-3 min-w-0 flex items-center space-x-3">
            <div className="w-10 h-10 bg-yellow-100 rounded-lg flex items-center justify-center">
              <svg className="w-5 h-5 text-yellow-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
              </svg>
            </div>
            <div>
              <p className="text-sm font-medium text-yellow-800">Pendientes</p>
              <p className="text-lg font-bold text-yellow-700">
                {(statusCounts['PENDING'] || 0) + (statusCounts['PREPARING'] || 0) + (statusCounts['READY'] || 0)}
              </p>
            </div>
          </div>
          
          <div className="bg-gradient-to-r from-green-50 to-emerald-50 border border-green-200 rounded-xl px-4 py-3 min-w-0 flex items-center space-x-3">
            <div className="w-10 h-10 bg-green-100 rounded-lg flex items-center justify-center">
              <svg className="w-5 h-5 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1" />
              </svg>
            </div>
            <div>
              <p className="text-sm font-medium text-green-800">Ingresos</p>
              <p className="text-lg font-bold text-green-700">{formatPrice(totalRevenue)}</p>
            </div>
          </div>
        </div>
      </div>

      {/* Status Overview Cards */}
      <div className="grid grid-cols-2 lg:grid-cols-4 gap-4">
        {[
          { status: 'PENDING', label: 'Pendientes', color: 'from-gray-600 to-slate-700', bgColor: 'from-gray-100 to-slate-100', borderColor: 'border-gray-300' },
          { status: 'PREPARING', label: 'Preparando', color: 'from-yellow-600 to-orange-600', bgColor: 'from-yellow-100 to-orange-100', borderColor: 'border-yellow-300' },
          { status: 'READY', label: 'Listos', color: 'from-blue-600 to-indigo-600', bgColor: 'from-blue-100 to-indigo-100', borderColor: 'border-blue-300' },
          { status: 'PAID', label: 'Pagados', color: 'from-green-600 to-emerald-600', bgColor: 'from-green-100 to-emerald-100', borderColor: 'border-green-300' }
        ].map(({ status, label, color, bgColor, borderColor }) => (
          <Card key={status} className={cn("bg-gradient-to-r", bgColor, "border", borderColor)}>
            <CardContent className="p-4">
              <div className="flex items-center space-x-3">
                <div className={cn("w-8 h-8 rounded-lg bg-gradient-to-r", color, "flex items-center justify-center")}>
                  <span className="text-white font-bold text-sm">{statusCounts[status] || 0}</span>
                </div>
                <div>
                  <p className="font-medium text-gray-900">{label}</p>
                  <p className="text-xs text-gray-700">{status}</p>
                </div>
              </div>
            </CardContent>
          </Card>
        ))}
      </div>
      
      {/* Enhanced Filters */}
      <OrderFilters 
        filter={orderFilter}
        setFilter={setOrderFilter}
        sort={orderSort}
        setSort={setOrderSort}
        setPage={setPage}
      />

      {/* Enhanced Content Area */}
      {ordersLoading ? (
        <div className="flex flex-col items-center justify-center py-20 space-y-6">
          <div className="relative">
            <div className="w-20 h-20 border-4 border-gray-200 border-t-green-500 rounded-full animate-spin"></div>
            <div className="absolute inset-0 flex items-center justify-center">
              <svg className="w-8 h-8 text-green-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M16 11V7a4 4 0 00-8 0v4M5 9h14l1 12H4L5 9z" />
              </svg>
            </div>
          </div>
          <div className="text-center">
            <p className="text-xl font-medium text-gray-600">Cargando pedidos...</p>
            <p className="text-sm text-gray-500 mt-1">Obteniendo la lista de pedidos</p>
          </div>
        </div>
      ) : ordersError ? (
        <div className="bg-gradient-to-r from-red-50 to-red-100 border border-red-200 rounded-2xl p-8">
          <div className="flex items-start space-x-4">
            <div className="flex-shrink-0">
              <div className="w-12 h-12 bg-red-100 rounded-xl flex items-center justify-center">
                <svg className="w-6 h-6 text-red-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
              </div>
            </div>
            <div className="flex-1">
              <h3 className="text-lg font-semibold text-red-800 mb-2">Error cargando pedidos</h3>
              <p className="text-red-700 mb-4">{getErrorMessage(ordersError)}</p>
              <Button 
                variant="info"
                onClick={() => refetchOrders()}
                className="flex items-center space-x-2"
              >
                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                </svg>
                <span>Reintentar</span>
              </Button>
            </div>
          </div>
        </div>
      ) : (
        <>
          {/* Enhanced Orders Grid */}
          {orders.length === 0 ? (
            <div className="flex flex-col items-center justify-center py-20 space-y-6">
              <div className="w-32 h-32 bg-gray-100 rounded-2xl flex items-center justify-center">
                <svg className="w-16 h-16 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M16 11V7a4 4 0 00-8 0v4M5 9h14l1 12H4L5 9z" />
                </svg>
              </div>
              <div className="text-center">
                <h3 className="text-xl font-medium text-gray-900 mb-2">No hay pedidos</h3>
                <p className="text-gray-500 mb-4">Los pedidos aparecerán aquí cuando los clientes hagan pedidos</p>
                <p className="text-sm text-gray-400">Los clientes pueden hacer pedidos escaneando el código QR de las mesas</p>
              </div>
            </div>
          ) : (
            <div className="grid grid-cols-1 lg:grid-cols-2 xl:grid-cols-3 gap-6">
              {orders.map((order) => {
                const orderTotal = order.orderItems?.reduce((sum, item) => sum + (item.price * item.quantity), 0) || 0;
                const statusColor = {
                  'PENDING': 'border-l-gray-400 bg-gray-50',
                  'PREPARING': 'border-l-yellow-400 bg-yellow-50',
                  'READY': 'border-l-blue-400 bg-blue-50',
                  'PAID': 'border-l-green-400 bg-green-50'
                }[order.status] || 'border-l-gray-400 bg-gray-50';

                return (
                  <Card key={order.id} className={cn("border-l-4 transition-all duration-300 hover:shadow-lg hover:-translate-y-1", statusColor)}>
                    <CardContent className="p-6">
                      {/* Order Header */}
                      <div className="flex items-center justify-between mb-4">
                        <div>
                          <div className="flex items-center space-x-2">
                            <h3 className="text-lg font-semibold text-gray-900">Pedido #{order.id}</h3>
                            <Badge variant={getStatusBadgeVariant(order.status)}>
                              {order.status}
                            </Badge>
                          </div>
                          <div className="flex items-center space-x-4 mt-2 text-sm text-gray-600">
                            <div className="flex items-center space-x-1">
                              <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z" />
                              </svg>
                              <span>Mesa {order.table?.number}</span>
                            </div>
                            <div className="flex items-center space-x-1">
                              <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
                              </svg>
                              <span>{new Date(order.createdAt).toLocaleTimeString('es-ES', { 
                                hour: '2-digit', 
                                minute: '2-digit' 
                              })}</span>
                            </div>
                          </div>
                        </div>
                        <div className="text-right">
                          <p className="text-2xl font-bold text-gray-900">{formatPrice(orderTotal)}</p>
                          <p className="text-xs text-gray-500">Total</p>
                        </div>
                      </div>

                      {/* Order Items */}
                      <div className="bg-white rounded-lg border p-4 mb-4">
                        <h4 className="font-medium text-gray-900 mb-3 flex items-center space-x-2">
                          <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2" />
                          </svg>
                          <span>Artículos del pedido</span>
                        </h4>
                        <div className="space-y-2 max-h-32 overflow-y-auto">
                          {order.orderItems?.map((item) => (
                            <div key={item.id} className="flex items-center justify-between text-sm">
                              <div className="flex items-center space-x-2">
                                <span className="w-6 h-6 bg-gray-100 rounded-full flex items-center justify-center text-xs font-medium">
                                  {item.quantity}
                                </span>
                                <span className="text-gray-900">{item.menuItem?.name}</span>
                              </div>
                              <span className="font-medium text-gray-700">{formatPrice(item.price * item.quantity)}</span>
                            </div>
                          ))}
                        </div>
                      </div>

                      {/* Action Buttons */}
                      {order.status !== 'PAID' && (
                        <div className="flex flex-wrap gap-2">
                          {order.status === 'PENDING' && (
                            <Button
                              variant="warning"
                              size="sm"
                              onClick={() => handleUpdateOrderStatus(order.id, 'PREPARING')}
                              className="flex items-center space-x-1 flex-1"
                            >
                              <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
                              </svg>
                              <span>Preparar</span>
                            </Button>
                          )}
                          {(order.status === 'PREPARING' || order.status === 'PENDING') && (
                            <Button
                              variant="info"
                              size="sm"
                              onClick={() => handleUpdateOrderStatus(order.id, 'READY')}
                              className="flex items-center space-x-1 flex-1"
                            >
                              <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
                              </svg>
                              <span>Listo</span>
                            </Button>
                          )}
                          <Button
                            variant="success"
                            size="sm"
                            onClick={() => handlePayOrder(order.id)}
                            className="flex items-center space-x-1 flex-1"
                          >
                            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1" />
                            </svg>
                            <span>Cobrar</span>
                          </Button>
                        </div>
                      )}
                    </CardContent>
                  </Card>
                );
              })}
            </div>
          )}

          {/* Enhanced Pagination */}
          {orders.length > 0 && (
            <div className="mt-8">
              <Pagination 
                currentPage={currentPage}
                setPage={setPage}
                hasMore={hasMore}
              />
            </div>
          )}
        </>
      )}
    </div>
  );
};
</file>

<file path="backend/package.json">
{
  "name": "proyecto-restaurantes-backend",
  "version": "1.0.0",
  "main": "src/server.ts",
  "scripts": {
    "dev": "ts-node-dev --respawn src/server.ts",
    "generate": "prisma generate --schema=./infrastructure/prisma/schema.prisma",
    "migrate": "prisma migrate dev --name init --schema=./infrastructure/prisma/schema.prisma",
    "lint": "eslint .",
    "lint:fix": "eslint . --fix"
  },
  "prisma": {
    "seed": "ts-node --transpile-only infrastructure/prisma/seed.ts"
  },
  "dependencies": {
    "@prisma/client": "^5.0.0",
    "@types/ws": "^8.18.1",
    "bcryptjs": "^2.4.3",
    "cors": "^2.8.5",
    "dataloader": "^2.2.3",
    "dotenv": "^16.5.0",
    "express": "^4.18.2",
    "graphql": "^16.6.0",
    "graphql-subscriptions": "^3.0.0",
    "graphql-ws": "^6.0.5",
    "graphql-yoga": "^3.9.1",
    "jsonwebtoken": "^9.0.2",
    "ws": "^8.18.2"
  },
  "devDependencies": {
    "@types/bcryptjs": "^3.0.0",
    "@types/cors": "^2.8.17",
    "@types/express": "^5.0.1",
    "@types/jsonwebtoken": "^9.0.9",
    "@types/node": "^22.15.29",
    "@typescript-eslint/eslint-plugin": "^8.31.0",
    "@typescript-eslint/parser": "^8.31.0",
    "eslint": "^9.25.1",
    "eslint-config-prettier": "^10.1.2",
    "eslint-plugin-prettier": "^5.2.6",
    "prettier": "^3.5.3",
    "prisma": "^5.0.0",
    "ts-node": "^10.9.2",
    "ts-node-dev": "^2.0.0",
    "typescript": "^5.8.3"
  }
}
</file>

<file path="backend/src/server.ts">
// src/server.ts
import dotenv from "dotenv";

// Load environment variables from .env file
dotenv.config();

import express, { Request, Response, NextFunction } from "express";
import cors from "cors";
import { createServer } from "http";
import { createYoga, createSchema } from "graphql-yoga";
import { WebSocketServer } from 'ws';
import { useServer } from 'graphql-ws/use/ws';
import { createGraphQLContext } from "../interfaces/graphql/context";
import { menuResolvers } from "../interfaces/graphql/resolvers/menuResolvers";
import { orderResolvers } from "../interfaces/graphql/resolvers/orderResolvers";
import { userResolvers } from "../interfaces/graphql/resolvers/userResolvers";
import { tableResolvers } from "../interfaces/graphql/resolvers/tableResolvers";
import { paymentResolvers } from "../interfaces/graphql/resolvers/paymentResolvers";
import { subscriptionResolvers } from "../interfaces/graphql/resolvers/subscriptionResolvers";

// GraphQL Type Definitions
const typeDefs = `
  scalar DateTime

  enum OrderStatus {
    OPEN
    PENDING
    PREPARING
    READY
    DELIVERED
    PAID
    CANCELLED
  }

  enum RoleEnum {
    SUPERADMIN
    MANAGER
    STAFF
  }

  type User {
    id: Int!
    email: String!
    role: RoleEnum!
    createdAt: DateTime!
  }

  type MenuItem {
    id: Int!
    sku: String!
    name: String!
    price: Float!
    imageUrl: String
    isAvailable: Boolean!
    createdAt: DateTime!
  }

  type Table {
    id: Int!
    number: Int!
    capacity: Int!
    qrCode: String
    orders: [Order!]!
  }

  type OrderItem {
    id: Int!
    orderId: Int!
    menuItemId: Int!
    menuItem: MenuItem!
    quantity: Int!
    price: Float!
    total: Float!
  }

  type Order {
    id: Int!
    status: OrderStatus!
    tableId: Int!
    table: Table!
    userId: Int!
    user: User!
    createdAt: DateTime!
    orderItems: [OrderItem!]!
    totalAmount: Float!
  }

  type PageInfo {
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
    startCursor: String
    endCursor: String
  }

  type MenuItemEdge {
    node: MenuItem!
    cursor: String!
  }

  type MenuItemConnection {
    edges: [MenuItemEdge!]!
    pageInfo: PageInfo!
  }

  type OrderEdge {
    node: Order!
    cursor: String!
  }

  type OrderConnection {
    edges: [OrderEdge!]!
    pageInfo: PageInfo!
  }

  type OrdersResult {
    orders: [Order!]!
    totalCount: Int!
  }

  type OrderStatusCount {
    status: String!
    count: Int!
  }

  input MenuItemFilter {
    name: String
    priceMin: Float
    priceMax: Float
    isAvailable: Boolean
  }

  input MenuItemSort {
    field: String!
    order: String!
  }

  input TableFilter {
    number: Int
    capacityMin: Int
    capacityMax: Int
    hasQrCode: Boolean
  }

  input TableSort {
    field: String!
    order: String!
  }

  input OrderFilter {
    status: OrderStatus
    tableId: Int
    userId: Int
    createdAfter: String
    createdBefore: String
  }

  input OrderSort {
    field: String!
    order: String!
  }

  input CreateOrderByQrCodeInput {
    qrCode: String!
    items: [CreateOrderItemInput!]!
  }

  input CreateOrderItemInput {
    menuItemId: Int!
    quantity: Int!
  }

  input UpdateOrderStatusInput {
    orderId: Int!
    status: OrderStatus!
  }

  type AuthPayload {
    token: String!
    user: User!
  }

  type Payment {
    id: ID!
    orderId: Int!
    amount: Float!
    method: String!
    paidAt: String!
  }

  input OrderItemInput {
    menuItemId: ID!
    quantity: Int!
  }

  type Query {
    menuItems(
      filter: MenuItemFilter
      sort: MenuItemSort
      first: Int
      after: String
    ): MenuItemConnection!
    
    # Add the items field that the frontend expects
    items(
      filter: MenuItemFilter
      sort: MenuItemSort
      limit: Int
      offset: Int
    ): [MenuItem!]!
    
    menuItem(id: Int!): MenuItem
    menuItemsCount(filter: MenuItemFilter): Int!
    
    # User queries
    me: User!
    
    # Table queries
    tables(
      filter: TableFilter
      sort: TableSort
      limit: Int
      offset: Int
    ): [Table!]!
    getTableById(id: Int!): Table
    getTableByQrCode(qrCode: String!): Table
    tablesCount(filter: TableFilter): Int!
    
    # Order queries
    orders(
      filter: OrderFilter
      sort: OrderSort
      limit: Int
      offset: Int
    ): OrdersResult!
    
    order(id: Int!): Order
    ordersByQrCode(qrCode: String!): [Order!]!
    getOrdersByQrCode(qrCode: String!): [Order!]!
    ordersCount(filter: OrderFilter): Int!
    ordersCountByStatus: [OrderStatusCount!]!
  }

  type Mutation {
    # Authentication
    login(email: String!, password: String!): AuthPayload!
    signup(email: String!, password: String!, name: String, role: RoleEnum): AuthPayload!
    
    # Menu management
    createItem(title: String!, price: Float!, imageUrl: String): MenuItem!
    editItem(id: ID!, title: String, price: Float, imageUrl: String): MenuItem!
    deleteItem(id: ID!): MenuItem!
    
    # Table management
    addTable: Table!
    removeTable: Table!
    generateQrCodeForTable(tableId: ID!): Table!
    
    # Order management
    createOrder(tableId: ID!, itemId: ID!): Order!
    createOrderByQrCode(qrCode: String!, items: [OrderItemInput!]!): Order!
    setOrderStatus(id: ID!, status: String!): Order!
    deleteOrder(id: ID!): Order!
    updateOrderStatus(input: UpdateOrderStatusInput!): Order!
    
    # Payment management
    createPaymentForOrder(type: String!, orderId: ID!): Payment!
    createPaymentForTable(type: String!, tableId: ID!): [Order!]!
  }

  type Subscription {
    orderCreated: Order!
    orderUpdated: Order!
    orderStatusChanged: Order!
  }
`;

// Merge resolvers from domain modules
const resolvers = {
  Query: {
    ...menuResolvers.Query,
    ...orderResolvers.Query,
    ...userResolvers.Query,
    ...tableResolvers.Query,
  },
  Mutation: {
    ...menuResolvers.Mutation,
    ...orderResolvers.Mutation,
    ...userResolvers.Mutation,
    ...tableResolvers.Mutation,
    ...paymentResolvers.Mutation,
  },
  Subscription: {
    ...subscriptionResolvers.Subscription,
  },
  MenuItem: {
    ...menuResolvers.MenuItem,
  },
  Order: {
    ...orderResolvers.Order,
  },
  OrderItem: {
    ...orderResolvers.OrderItem,
  },
  Table: {
    ...tableResolvers.Table,
  },
  DateTime: {
    serialize: (value: Date | string | number) => {
      // Si el valor es nulo o undefined, devolver null
      if (value == null) return null;
      
      // Si es un número (timestamp), convertir a Date
      if (typeof value === 'number') {
        const date = new Date(value);
        return date.toISOString();
      }
      
      // Si es una string, verificar si es una fecha válida
      if (typeof value === 'string') {
        const date = new Date(value);
        if (isNaN(date.getTime())) {
          throw new Error(`Invalid date string: ${value}`);
        }
        return date.toISOString();
      }
      
      // Si es una instancia de Date
      if (value instanceof Date) {
        if (isNaN(value.getTime())) {
          throw new Error(`Invalid Date object`);
        }
        return value.toISOString();
      }
      
      // Si llegamos aquí, el tipo no es válido
      throw new Error(`Value is not a valid date: ${value} (type: ${typeof value})`);
    },
    parseValue: (value: string) => {
      const date = new Date(value);
      if (isNaN(date.getTime())) {
        throw new Error(`Invalid date string: ${value}`);
      }
      return date;
    },
    parseLiteral: (ast: { value: string }) => {
      const date = new Date(ast.value);
      if (isNaN(date.getTime())) {
        throw new Error(`Invalid date string: ${ast.value}`);
      }
      return date;
    },
  },
};

async function main(): Promise<void> {
  const app = express();
  app.use(cors({
    origin: ['http://localhost:3000', 'http://localhost:3001'],
    credentials: true
  }));
  app.use(express.json());

  // Build GraphQL schema
  const schema = createSchema({ typeDefs, resolvers });

  // Initialize Yoga with proper context function
  const yoga = createYoga({
    schema,
    context: async (params) => {
      // Extract the request object from GraphQL Yoga context
      const req = params.request;
      return createGraphQLContext(req);
    },
    // Habilitar CORS para WebSockets
    cors: {
      origin: ['http://localhost:3000', 'http://localhost:3001'],
      credentials: true
    },
    graphiql: {
      defaultQuery: `
        query GetMenuItems {
          menuItems(first: 10) {
            edges {
              node {
                id
                name
                price
                isAvailable
              }
              cursor
            }
            pageInfo {
              hasNextPage
              hasPreviousPage
              startCursor
              endCursor
            }
          }
        }

        mutation CreateOrder {
          createOrderByQrCode(qrCode: "table-1-123456789", items: [
            { menuItemId: "1", quantity: 2 }
            { menuItemId: "2", quantity: 1 }
          ]) {
            id
            status
            totalAmount
            table {
              number
            }
            orderItems {
              quantity
              price
              total
              menuItem {
                name
              }
            }
          }
        }
        
        subscription OnOrderCreated {
          orderCreated {
            id
            status
            tableId
            userId
            createdAt
            orderItems {
              id
              quantity
              price
              menuItem {
                id
                name
                price
              }
            }
            table {
              id
              number
            }
          }
        }
      `,
      headers: JSON.stringify(
        {
          Authorization: "Bearer TOKEN_DE_EJEMPLO",
        },
        null,
        2,
      ),
    },
  });

  const port = process.env.PORT ?? 4000;
  const httpServer = createServer(app);

  // Configurar WebSocket Server para suscripciones
  const wsServer = new WebSocketServer({
    server: httpServer,
    path: '/graphql',
  });

  // Configurar el servidor de GraphQL-WS
  const serverCleanup = useServer(
    {
      schema,
      context: async (ctx, msg, args) => {
        // Extraer token de los parámetros de conexión
        const authHeader = ctx.connectionParams?.authorization;
        
        // Crear un objeto request mock para el contexto
        const mockRequest = {
          headers: {
            authorization: authHeader || '',
            get: (name: string) => {
              if (name.toLowerCase() === 'authorization') {
                return authHeader || '';
              }
              return '';
            }
          }
        };
        
        return createGraphQLContext(mockRequest);
      },
      onConnect: (ctx) => {
        console.log('🔌 WebSocket client connected for subscriptions');
        return true;
      },
      onDisconnect: () => {
        console.log('🔌 WebSocket client disconnected');
      },
    },
    wsServer
  );

  // Use Yoga as Express middleware
  app.use("/graphql", yoga as any);
  
  // Graceful shutdown
  process.on('SIGTERM', () => {
    console.log('SIGTERM received, shutting down gracefully');
    serverCleanup.dispose();
    httpServer.close(() => {
      console.log('HTTP server closed');
    });
  });
  
  httpServer.listen(port, () => {
    console.log(`🚀 Server ready at http://localhost:${port}/graphql`);
    console.log(`🔌 WebSocket server ready at ws://localhost:${port}/graphql`);
  });
}

main().catch(console.error);
</file>

<file path="frontend-nextjs/src/components/Dashboard.tsx">
'use client';

import React, { useState, useEffect } from 'react';
import { Button } from './ui';
import { CONTAINER, FLEX, TEXT, cn } from '../lib/styles';
import { useDashboardData } from '../hooks/useDashboardData';
import { useDashboardUtils } from '../hooks/useDashboardUtils';
import { useDashboardActions } from '../hooks/useDashboardActions';
import { MenuTab } from './dashboard/MenuTab';
import { TablesTab } from './dashboard/TablesTab';
import { OrdersTab } from './dashboard/OrdersTab';

interface DashboardProps {
  onLogout: () => void;
}

const Dashboard: React.FC<DashboardProps> = ({ onLogout }) => {
  const [activeTab, setActiveTab] = useState('menu');
  const [sidebarCollapsed, setSidebarCollapsed] = useState(false);
  
  // Custom hooks
  const dashboardData = useDashboardData();
  const dashboardUtils = useDashboardUtils(dashboardData.userData);
  const dashboardActions = useDashboardActions({
    createMenuItem: dashboardData.createMenuItem,
    editMenuItem: dashboardData.editMenuItem,
    deleteMenuItem: dashboardData.deleteMenuItem,
    addTable: dashboardData.addTable,
    removeTable: dashboardData.removeTable,
    createOrder: dashboardData.createOrder,
    setOrderStatus: dashboardData.setOrderStatus,
    createPayment: dashboardData.createPayment,
    generateQrCode: dashboardData.generateQrCode,
    refetchMenu: dashboardData.refetchMenu,
    refetchTables: dashboardData.refetchTables,
    refetchOrders: dashboardData.refetchOrders,
    getErrorMessage: dashboardUtils.getErrorMessage
  });

  // Check if we have connection issues
  const hasConnectionIssues = dashboardUtils.hasConnectionIssues(
    dashboardData.menuError,
    dashboardData.tablesError,
    dashboardData.ordersError
  );

  // Tab configuration with icons and improved styling
  const tabs = [
    {
      id: 'menu',
      label: 'Menú',
      icon: '🍽️',
      iconSvg: (
        <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-3 7h3m-3 4h3m-6-4h.01M9 16h.01" />
        </svg>
      ),
      count: dashboardData.menuCountLoading ? '...' : (dashboardData.menuCountData?.menuItemsCount || 0),
      color: 'from-orange-500 to-red-500',
      description: 'Gestiona platos y bebidas'
    },
    {
      id: 'tables',
      label: 'Mesas',
      icon: '🪑',
      iconSvg: (
        <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 21V5a2 2 0 00-2-2H7a2 2 0 00-2 2v16m14 0h2m-2 0h-5m-9 0H3m2 0h5M9 7h1m-1 4h1m4-4h1m-1 4h1m-5 10v-5a1 1 0 011-1h2a1 1 0 011 1v5m-4 0h4" />
        </svg>
      ),
      count: dashboardData.tablesCountLoading ? '...' : (dashboardData.tablesCountData?.tablesCount || 0),
      color: 'from-blue-500 to-indigo-500',
      description: 'Administra mesas y capacidad'
    },
    {
      id: 'orders',
      label: 'Pedidos',
      icon: '📋',
      iconSvg: (
        <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M16 11V7a4 4 0 00-8 0v4M5 9h14l1 12H4L5 9z" />
        </svg>
      ),
      count: dashboardData.ordersCountLoading ? '...' : (dashboardData.ordersCountData?.ordersCount || 0),
      color: 'from-green-500 to-teal-500',
      description: 'Maneja pedidos y pagos'
    }
  ];

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-50 via-blue-50 to-indigo-50">
      {/* Top Header */}
      <header className="bg-white/90 backdrop-blur-xl border-b border-gray-200/50 sticky top-0 z-50 shadow-sm">
        <div className="mx-auto max-w-7xl px-4 sm:px-6 lg:px-8">
          <div className="flex h-16 items-center justify-between">
            {/* Logo and Brand */}
            <div className="flex items-center space-x-4">
              <div className="flex items-center space-x-3">
                <div className="relative">
                  <div className="h-10 w-10 rounded-xl bg-gradient-to-br from-indigo-600 to-purple-600 p-2 shadow-lg">
                    <svg className="h-full w-full text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 21V5a2 2 0 00-2-2H7a2 2 0 00-2 2v16m14 0h2m-2 0h-5m-9 0H3m2 0h5M9 7h1m-1 4h1m4-4h1m-1 4h1m-5 10v-5a1 1 0 011-1h2a1 1 0 011 1v5m-4 0h4" />
                    </svg>
                  </div>
                  <div className="absolute -top-1 -right-1 h-4 w-4 rounded-full bg-green-400 border-2 border-white"></div>
                </div>
                <div>
                  <h1 className="text-xl font-bold bg-gradient-to-r from-gray-900 to-gray-600 bg-clip-text text-transparent">
                    RestaurantePro
                  </h1>
                  <p className="text-xs text-gray-500">Sistema de gestión</p>
                </div>
              </div>
            </div>
            
            {/* User Info and Actions */}
            <div className="flex items-center space-x-4">
              {/* Quick Stats */}
              <div className="hidden lg:flex items-center space-x-3 text-sm">
                <div className="flex items-center space-x-2 px-3 py-1 bg-orange-50 border border-orange-200 rounded-lg">
                  <span className="text-orange-600">🍽️</span>
                  <span className="font-medium text-orange-700">
                    {dashboardData.menuCountLoading ? '...' : (dashboardData.menuCountData?.menuItemsCount || 0)}
                  </span>
                </div>
                <div className="flex items-center space-x-2 px-3 py-1 bg-blue-50 border border-blue-200 rounded-lg">
                  <span className="text-blue-600">🪑</span>
                  <span className="font-medium text-blue-700">
                    {dashboardData.tablesCountLoading ? '...' : (dashboardData.tablesCountData?.tablesCount || 0)}
                  </span>
                </div>
                <div className="flex items-center space-x-2 px-3 py-1 bg-green-50 border border-green-200 rounded-lg">
                  <span className="text-green-600">📋</span>
                  <span className="font-medium text-green-700">
                    {dashboardData.ordersCountLoading ? '...' : (dashboardData.ordersCountData?.ordersCount || 0)}
                  </span>
                </div>
              </div>

              {/* User Profile */}
              <div className="flex items-center space-x-3">
                {dashboardData.userLoading ? (
                  <div className="flex items-center space-x-2">
                    <div className="h-8 w-8 rounded-full bg-gray-200 animate-pulse"></div>
                    <div className="h-4 w-20 bg-gray-200 rounded animate-pulse"></div>
                  </div>
                ) : dashboardData.userData?.me ? (
                  <div className="flex items-center space-x-3">
                    <div className="h-8 w-8 rounded-full bg-gradient-to-br from-indigo-500 to-purple-600 flex items-center justify-center text-white font-medium text-sm">
                      {dashboardData.userData.me.email.charAt(0).toUpperCase()}
                    </div>
                    <div className="hidden sm:block text-right">
                      <p className="text-sm font-medium text-gray-900 truncate max-w-32">
                        {dashboardData.userData.me.email}
                      </p>
                      <p className="text-xs text-gray-500 capitalize">
                        {dashboardData.userData.me.role}
                      </p>
                    </div>
                  </div>
                ) : (
                  <div className="text-red-600 text-sm">Error de usuario</div>
                )}
                
                <Button 
                  variant="danger" 
                  size="sm"
                  onClick={onLogout}
                  className="flex items-center space-x-2"
                >
                  <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1" />
                  </svg>
                  <span className="hidden sm:inline">Salir</span>
                </Button>
              </div>
            </div>
          </div>
        </div>
      </header>

      <div className="flex">
        {/* Sidebar Navigation */}
        <aside className={cn(
          "bg-white/80 backdrop-blur-sm border-r border-gray-200/50 transition-all duration-300 ease-in-out",
          sidebarCollapsed ? "w-16" : "w-64"
        )}>
          <div className="p-4">
            {/* Collapse Toggle */}
            <button
              onClick={() => setSidebarCollapsed(!sidebarCollapsed)}
              className="w-full flex items-center justify-center p-2 rounded-lg hover:bg-gray-100 transition-colors mb-4"
            >
              <svg className={cn("w-5 h-5 transition-transform", sidebarCollapsed && "rotate-180")} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M11 19l-7-7 7-7m8 14l-7-7 7-7" />
              </svg>
            </button>

            {/* Navigation Items */}
            <nav className="space-y-2">
              {tabs.map((tab) => (
                <button
                  key={tab.id}
                  onClick={() => setActiveTab(tab.id)}
                  className={cn(
                    "w-full flex items-center space-x-3 px-3 py-3 rounded-xl transition-all duration-200 group relative",
                    activeTab === tab.id
                      ? `bg-gradient-to-r ${tab.color} text-white shadow-lg transform scale-105`
                      : "text-gray-600 hover:bg-gray-50 hover:text-gray-900"
                  )}
                >
                  <div className={cn(
                    "flex-shrink-0 text-xl",
                    !sidebarCollapsed && "mr-1"
                  )}>
                    {tab.icon}
                  </div>
                  
                  {!sidebarCollapsed && (
                    <>
                      <div className="flex-1 text-left">
                        <div className="font-medium">{tab.label}</div>
                        <div className={cn(
                          "text-xs",
                          activeTab === tab.id ? "text-white/80" : "text-gray-500"
                        )}>
                          {tab.description}
                        </div>
                      </div>
                      
                      {tab.count > 0 && (
                        <span className={cn(
                          "px-2 py-1 rounded-full text-xs font-medium",
                          activeTab === tab.id
                            ? "bg-white/20 text-white"
                            : "bg-gray-200 text-gray-600"
                        )}>
                          {tab.count}
                        </span>
                      )}
                    </>
                  )}
                  
                  {sidebarCollapsed && tab.count > 0 && (
                    <div className="absolute -top-1 -right-1 h-5 w-5 bg-red-500 text-white text-xs rounded-full flex items-center justify-center">
                      {tab.count}
                    </div>
                  )}
                </button>
              ))}
            </nav>
          </div>
        </aside>

        {/* Main Content */}
        <main className="flex-1 overflow-hidden">
          {/* Connection Status Banner */}
          {hasConnectionIssues && (
            <div className="m-4 bg-gradient-to-r from-red-50 to-red-100 border border-red-200 rounded-xl p-4 shadow-sm">
              <div className="flex items-start space-x-3">
                <div className="flex-shrink-0">
                  <div className="h-8 w-8 bg-red-100 rounded-full flex items-center justify-center">
                    <svg className="h-5 w-5 text-red-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16.5c-.77.833.192 2.5 1.732 2.5z" />
                    </svg>
                  </div>
                </div>
                <div className="flex-1">
                  <h3 className="text-sm font-semibold text-red-800">Problema de conexión</h3>
                  <p className="text-sm text-red-700 mt-1">
                    No se puede conectar al servidor backend. Asegúrate de que esté ejecutándose en 
                    <code className="mx-1 px-2 py-0.5 bg-red-200 rounded text-xs">http://localhost:4000/graphql</code>
                  </p>
                </div>
              </div>
            </div>
          )}

          {/* Tab Content */}
          <div className="p-4 h-full overflow-auto">
            <div className="bg-white rounded-2xl shadow-sm border border-gray-100 min-h-full">
              {activeTab === 'menu' && (
                <MenuTab
                  menuData={dashboardData.menuData}
                  menuLoading={dashboardData.menuLoading}
                  menuError={dashboardData.menuError}
                  refetchMenu={dashboardData.refetchMenu}
                  itemsPerPage={dashboardData.itemsPerPage}
                  menuFilter={dashboardData.menuFilter}
                  setMenuFilter={dashboardData.setMenuFilter}
                  menuSort={dashboardData.menuSort}
                  setMenuSort={dashboardData.setMenuSort}
                  menuPage={dashboardData.menuPage}
                  setMenuPage={dashboardData.setMenuPage}
                  newItemName={dashboardActions.newItemName}
                  setNewItemName={dashboardActions.setNewItemName}
                  newItemPrice={dashboardActions.newItemPrice}
                  setNewItemPrice={dashboardActions.setNewItemPrice}
                  newItemImageUrl={dashboardActions.newItemImageUrl}
                  setNewItemImageUrl={dashboardActions.setNewItemImageUrl}
                  handleCreateMenuItem={dashboardActions.handleCreateMenuItem}
                  handleEditMenuItem={dashboardActions.handleEditMenuItem}
                  handleDeleteMenuItem={dashboardActions.handleDeleteMenuItem}
                  editingItem={dashboardActions.editingItem}
                  setEditingItem={dashboardActions.setEditingItem}
                  startEditing={dashboardActions.startEditing}
                  cancelEditing={dashboardActions.cancelEditing}
                  formatPrice={dashboardUtils.formatPrice}
                  getErrorMessage={dashboardUtils.getErrorMessage}
                  canManageMenu={dashboardUtils.canManageMenu}
                />
              )}

              {activeTab === 'tables' && (
                <TablesTab
                  tablesData={dashboardData.tablesData}
                  tablesLoading={dashboardData.tablesLoading}
                  tablesError={dashboardData.tablesError}
                  refetchTables={dashboardData.refetchTables}
                  menuData={dashboardData.menuData}
                  itemsPerPage={dashboardData.itemsPerPage}
                  tablesCountData={dashboardData.tablesCountData}
                  tablesCountLoading={dashboardData.tablesCountLoading}
                  tableFilter={dashboardData.tableFilter}
                  setTableFilter={dashboardData.setTableFilter}
                  tableSort={dashboardData.tableSort}
                  setTableSort={dashboardData.setTableSort}
                  tablePage={dashboardData.tablePage}
                  setTablePage={dashboardData.setTablePage}
                  handleAddTable={dashboardActions.handleAddTable}
                  handleRemoveTable={dashboardActions.handleRemoveTable}
                  handleCreateOrder={dashboardActions.handleCreateOrder}
                  handleUpdateOrderStatus={dashboardActions.handleUpdateOrderStatus}
                  handlePayOrder={dashboardActions.handlePayOrder}
                  handleGenerateQrCode={dashboardActions.handleGenerateQrCode}
                  addTableLoading={dashboardData.addTableLoading}
                  removeTableLoading={dashboardData.removeTableLoading}
                  formatPrice={dashboardUtils.formatPrice}
                  getErrorMessage={dashboardUtils.getErrorMessage}
                  getQrCodeUrl={dashboardUtils.getQrCodeUrl}
                  canManageTables={dashboardUtils.canManageTables}
                />
              )}

              {activeTab === 'orders' && (
                <OrdersTab
                  ordersData={dashboardData.ordersData}
                  ordersLoading={dashboardData.ordersLoading}
                  ordersError={dashboardData.ordersError}
                  refetchOrders={dashboardData.refetchOrders}
                  currentPage={dashboardData.orderPage}
                  setPage={dashboardData.setOrderPage}
                  hasMore={(() => {
                    const totalCount = dashboardData.ordersData?.orders?.totalCount || 0;
                    const currentPage = dashboardData.orderPage;
                    const itemsPerPage = dashboardData.itemsPerPage;
                    return (currentPage + 1) * itemsPerPage < totalCount;
                  })()}
                  orderFilter={dashboardData.orderFilter}
                  setOrderFilter={dashboardData.setOrderFilter}
                  orderSort={dashboardData.orderSort}
                  setOrderSort={dashboardData.setOrderSort}
                  handleUpdateOrderStatus={dashboardActions.handleUpdateOrderStatus}
                  handlePayOrder={dashboardActions.handlePayOrder}
                  formatPrice={dashboardUtils.formatPrice}
                  getErrorMessage={dashboardUtils.getErrorMessage}
                  ordersCountByStatusData={dashboardData.ordersCountByStatusData}
                  ordersCountByStatusLoading={dashboardData.ordersCountByStatusLoading}
                />
              )}
            </div>
          </div>
        </main>
      </div>
    </div>
  );
};

export default Dashboard;
</file>

</files>
