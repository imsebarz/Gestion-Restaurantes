This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
prisma/
  migrations/
    20250424205455_init/
      migration.sql
    migration_lock.toml
  .env
  .env.example
  schema.prisma
src/
  auth.ts
  context.ts
  prisma.ts
  resolvers.ts
  schema.ts
  server.ts
package.json
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="prisma/migrations/20250424205455_init/migration.sql">
-- CreateEnum
CREATE TYPE "Role" AS ENUM ('USER', 'ADMIN');

-- CreateEnum
CREATE TYPE "OrderStatus" AS ENUM ('PENDING', 'PREPARING', 'READY', 'DELIVERED', 'PAID', 'CANCELLED');

-- CreateEnum
CREATE TYPE "PaymentType" AS ENUM ('CASH', 'CARD', 'OTHER');

-- CreateTable
CREATE TABLE "User" (
    "id" SERIAL NOT NULL,
    "email" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "password" TEXT NOT NULL,
    "role" "Role" NOT NULL DEFAULT 'USER',

    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Item" (
    "id" SERIAL NOT NULL,
    "title" TEXT NOT NULL,
    "description" TEXT NOT NULL,
    "imageUrl" TEXT NOT NULL,
    "price" DOUBLE PRECISION NOT NULL,

    CONSTRAINT "Item_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Table" (
    "id" TEXT NOT NULL,
    "number" SERIAL NOT NULL,

    CONSTRAINT "Table_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Order" (
    "id" SERIAL NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "tableId" TEXT NOT NULL,
    "itemId" INTEGER NOT NULL,
    "paymentId" INTEGER,
    "status" "OrderStatus" NOT NULL DEFAULT 'PENDING',

    CONSTRAINT "Order_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Payment" (
    "id" SERIAL NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "type" "PaymentType" NOT NULL,

    CONSTRAINT "Payment_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "User_email_key" ON "User"("email");

-- CreateIndex
CREATE UNIQUE INDEX "Table_number_key" ON "Table"("number");

-- AddForeignKey
ALTER TABLE "Order" ADD CONSTRAINT "Order_tableId_fkey" FOREIGN KEY ("tableId") REFERENCES "Table"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Order" ADD CONSTRAINT "Order_itemId_fkey" FOREIGN KEY ("itemId") REFERENCES "Item"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Order" ADD CONSTRAINT "Order_paymentId_fkey" FOREIGN KEY ("paymentId") REFERENCES "Payment"("id") ON DELETE SET NULL ON UPDATE CASCADE;
</file>

<file path="prisma/migrations/migration_lock.toml">
# Please do not edit this file manually
# It should be added in your version-control system (i.e. Git)
provider = "postgresql"
</file>

<file path="prisma/.env">
DATABASE_URL="postgresql://postgres@localhost:5432/proyecto_restaurantes"
APP_SECRET="a61de430f8b2897e813422e218bd708387781ddc740f66424d3228effd9e0b81"
</file>

<file path="prisma/.env.example">
DATABASE_URL="postgresql://usuario:clave@localhost:5432/proyecto_restaurantes"
APP_SECRET="tu_secreto_para_jwt_aquí"
</file>

<file path="prisma/schema.prisma">
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

enum Role {
  USER
  ADMIN
}

enum OrderStatus {
  PENDING
  PREPARING
  READY
  DELIVERED
  PAID
  CANCELLED
}

enum PaymentType {
  CASH
  CARD
  OTHER
}

model User {
  id       Int    @id @default(autoincrement())
  email    String @unique
  name     String
  password String
  role     Role   @default(USER)
}

model Item {
  id          Int      @id @default(autoincrement())
  title       String
  description String
  imageUrl    String
  price       Float
  orders      Order[]
}

model Table {
  id     String  @id @default(uuid())
  number Int     @unique @default(autoincrement())
  orders Order[]
}

model Order {
  id        Int         @id @default(autoincrement())
  createdAt DateTime    @default(now())
  tableId   String
  itemId    Int
  paymentId Int?
  status    OrderStatus @default(PENDING)
  table     Table       @relation(fields: [tableId], references: [id])
  item      Item        @relation(fields: [itemId], references: [id])
  payment   Payment?    @relation(fields: [paymentId], references: [id])
}

model Payment {
  id        Int         @id @default(autoincrement())
  createdAt DateTime    @default(now())
  type      PaymentType
  orders    Order[]
}
</file>

<file path="src/auth.ts">
import { verify, sign, JwtPayload } from 'jsonwebtoken';
import prisma from './prisma';
export const APP_SECRET = process.env.APP_SECRET!;
export interface Context { userId: number | null; }
export function getTokenPayload(token: string): JwtPayload {
  return verify(token, APP_SECRET) as JwtPayload;
}
export async function authenticate(req: any): Promise<Context> {
  const auth = req.headers.authorization || '';
  const token = auth.replace('Bearer ', '');
  if (!token) return { userId: null };
  try {
    const payload = getTokenPayload(token);
    return { userId: payload.userId };
  } catch {
    return { userId: null };
  }
}
export function requireAuth(ctx: Context) {
  if (!ctx.userId) throw new Error('No autorizado');
}
</file>

<file path="src/context.ts">
import { Request } from 'express';
import { authenticate, Context } from './auth';
export async function createContext({ req }: { req: Request }): Promise<Context> {
  return authenticate(req);
}
</file>

<file path="src/prisma.ts">
import { PrismaClient } from '@prisma/client';
const prisma = new PrismaClient();
export default prisma;
</file>

<file path="src/resolvers.ts">
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';
import prisma from './prisma';
import { APP_SECRET, requireAuth } from './auth';
import { Context } from './context';

export const resolvers = {
  Query: {
    items: () => prisma.item.findMany(),
    getOrdersByTableId: (_: any, { tableId }: any) =>
      prisma.order.findMany({ where: { tableId }, include: { item: true } })
  },
  Mutation: {
    signup: async (_: any, { email, password, name }: any) => {
      const hashed = await bcrypt.hash(password, 10);
      const user = await prisma.user.create({ data: { email, name, password: hashed } });
      const token = jwt.sign({ userId: user.id }, APP_SECRET);
      return { token, user };
    },
    login: async (_: any, { email, password }: any) => {
      const user = await prisma.user.findUnique({ where: { email } });
      if (!user) throw new Error('Usuario no existe');
      const valid = await bcrypt.compare(password, user.password);
      if (!valid) throw new Error('Contraseña inválida');
      const token = jwt.sign({ userId: user.id }, APP_SECRET);
      return { token, user };
    },
    createOrder: async (_: any, { tableId, itemId }: any, ctx: Context) => {
      requireAuth(ctx);
      return prisma.order.create({ data: { tableId, itemId: Number(itemId) } });
    },
    createPaymentForOrder: async (_: any, { type, orderId }: any, ctx: Context) => {
      requireAuth(ctx);
      const payment = await prisma.payment.create({ data: { type } });
      await prisma.order.update({
        where: { id: Number(orderId) },
        data: { paymentId: payment.id, status: 'PAID' }
      });
      return payment;
    }
  }
};
</file>

<file path="src/schema.ts">
// backend/src/schema.ts

export const typeDefs = /* GraphQL */ `
  type Item {
    id: ID!
    title: String!
    description: String!
    price: Float!
    imageUrl: String!
    orders: [Order!]
  }

  type Table {
    id: ID!
    number: Int!
    orders: [Order!]
  }

  enum OrderStatus {
    PENDING
    PREPARING
    READY
    DELIVERED
    PAID
    CANCELLED
  }

  enum NewOrderStatus {
    PENDING
    PREPARING
    READY
    DELIVERED
  }

  enum PaymentType {
    CASH
    CARD
    OTHER
  }

  type Order {
    id: ID!
    createdAt: String!
    table: Table!
    item: Item!
    payment: Payment
    status: OrderStatus!
  }

  type Payment {
    id: ID!
    createdAt: String!
    type: PaymentType!
    orders: [Order!]!
  }

  type AuthPayload {
    token: String!
    user: User!
  }

  type User {
    id: ID!
    name: String!
    email: String!
    role: String!
  }

  type Query {
    me: User!
    items: [Item!]!
    getItemById(id: ID!): Item
    tables: [Table!]!
    getTableById(id: ID!): Table
    orders: [Order!]!
    getOrdersByTableId(tableId: ID!): [Order!]!
    payments: [Payment!]!
    getPaymentById(id: ID!): Payment
  }

  type Mutation {
    signup(email: String!, password: String!, name: String!): AuthPayload!
    login(email: String!, password: String!): AuthPayload!
    createItem(title: String!, description: String!, price: Float!, imageUrl: String!): Item!
    deleteItem(id: ID!): Item!
    editItem(id: ID!, title: String, description: String, price: Float, imageUrl: String): Item!
    createOrder(tableId: ID!, itemId: ID!, paymentId: ID): Order!
    deleteOrder(id: ID!): Order!
    setOrderStatus(id: ID!, status: NewOrderStatus!): Order!
    cancelOrder(id: ID!): Order!
    createPaymentForOrder(type: PaymentType!, orderId: ID!): Payment!
    createPaymentForTable(type: PaymentType!, tableId: ID!): [Order!]!
    deletePayment(id: ID!): Payment!
    addTable: Table!
    removeTable: Table!
  }
`;
</file>

<file path="src/server.ts">
// backend/src/server.ts
import express, { Request, Response, NextFunction } from 'express';
import cors from 'cors';
import { createServer } from 'http';
import { createYoga, createSchema } from 'graphql-yoga';
import { typeDefs } from './schema';
import { resolvers } from './resolvers';
import { createContext } from './context';

async function main() {
  const app = express();
  app.use(cors());
  app.use(express.json());

  const schema = createSchema({ typeDefs, resolvers });
  const yoga = createYoga<{ req: Request; res: Response; } & ReturnType<typeof createContext>>({
    schema,
    context: createContext,
    graphiql: true,
  });

  // Middleware puente para que Express reconozca Yoga
  app.use(
    '/graphql',
    (req: Request, res: Response, next: NextFunction) => {
      yoga(req, res).catch(next);
    }
  );

  const port = process.env.PORT ?? 4000;
  createServer(app).listen(port, () => {
    console.log(`🚀 Server listo en http://localhost:${port}/graphql`);
  });
}

main().catch(console.error);
</file>

<file path="package.json">
{
  "name": "proyecto-restaurantes-backend",
  "version": "1.0.0",
  "main": "src/server.ts",
  "scripts": {
    "dev": "ts-node-dev --respawn src/server.ts",
    "generate": "prisma generate",
    "migrate": "prisma migrate dev --name init"
  },
  "dependencies": {
    "@prisma/client": "^5.0.0",
    "bcryptjs": "^2.4.3",
    "cors": "^2.8.5",
    "express": "^4.18.2",
    "graphql": "^16.6.0",
    "graphql-yoga": "^3.9.1",
    "jsonwebtoken": "^9.0.2"
  },
  "devDependencies": {
    "@types/bcryptjs": "^3.0.0",
    "@types/cors": "^2.8.17",
    "@types/express": "^5.0.1",
    "@types/jsonwebtoken": "^9.0.9",
    "@types/node": "^22.15.0",
    "prisma": "^5.0.0",
    "ts-node-dev": "^2.0.0",
    "typescript": "^5.1.3"
  }
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "outDir": "dist",
    "rootDir": "src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true
  }
}
</file>

</files>
